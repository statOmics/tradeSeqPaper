barplot(table(unlist(lapply(goList, length))))
which(unlist(lapply(goList, length)))==1)
which(unlist(lapply(goList, length))==1)
goList[[4305]]
# hlp <- cherry::construct(goList)
listLengths <- unlist(lapply(goList, length))
## filter and make DAG
keep <- listLengths >= 5 & listLengths < 1000
table(keep)
goList <- goList[keep]
hlp <- cherry::construct(goList)
istwoway(hlp)
cherry::istwoway(hlp)
## filter and make DAG
keep <- listLengths >= 5 #& listLengths < 1000
goList <- sapply(uniqGO, function(term){
goMapping$gene[goMapping$go %in% term]
})
names(goList) <- uniqGO
keep <- listLengths >= 5 #& listLengths < 1000
goListFiltered <- goList[keep]
hlp <- cherry::construct(goList)
## filter and make DAG
goList[[length(goList)+1]] <- patternGenes
keep <- listLengths >= 5 #& listLengths < 1000
goListFiltered <- goList[keep]
hlp <- cherry::construct(goList)
hlp <- cherry::construct(goListFiltered)
cl1
## start implementation
clust- <- 1
clx <- patternGenes[clRSEC == clust]
## start implementation
clust <- 1
clx <- patternGenes[clRSEC == clust]
cl
clx
sum(unlist(lapply(goList, function(x) "Ybx1" %in% x)))
class(glBoot)
## the silhouette value is biased to k-means / PAM since it's based on the same distance.
## a non-parametric approach would be to use bootstrapping.
pt <- slingPseudotime(crv,na=FALSE)
cw <- slingCurveWeights(crv)
## bootstrap cells
bootCells <- sample(1:ncol(counts), replace=TRUE)
ptBoot <- pt[bootCells,]
cwBoot <- cw[bootCells,]
countsBoot <- counts[,bootCells]
## refit tradeSeq
glBoot <- fitGAM(countsBoot, pseudotime=ptBoot, cellWeights=cwBoot,
verbose=TRUE, nknots=6)
## cluster using RSEC
rsecBoot <- clusterExpressionPatterns(glBoot, nPoints=100, genes=patternGenes)
rm(hlp)
## cluster using PAM
yhatBoot <- rsecBoot$yhatScaled
pamBoot <- cluster::pam(yhatBoot, k=length(unique(clRSEC))-1)
??adjustedRandIndex
mclust::adjustedRandIndex(primaryCluster(rsecBoot$rsec),
primaryCluster(primaryCluster(resRSEC$rsec)))
mclust::adjustedRandIndex(resPam$clustering,
pamBoot$clustering)
primaryCluster(rsecBoot$rsec)
mclust::adjustedRandIndex(primaryCluster(rsecBoot$rsec),
primaryCluster(resRSEC$rsec))
mclust::adjustedRandIndex(resPam$clustering,
pamBoot$clustering)
rm(list=ls())
setwd("~/Dropbox/compomicsVM/brainstat/hbcRegen/")
#setwd("/home/compomics/Dropbox/compomicsVM/brainstat/hbcRegen/")
here::set_here()
suppressPackageStartupMessages({
library(slingshot)
library(tradeSeq)
library(SingleCellExperiment)
library(cowplot)
library(rgl)
library(clusterExperiment)
library(RColorBrewer)
library(aggregation)
library(ggplot2)
library(pheatmap)
library(wesanderson)
})
sds <- readRDS("slingshot_OE.rds")
load("regenK5_scone_none,fq,ruv_k=1,no_bio,batch_rsec_adjP_mergecutoff_0.01_20190609_085359.Rda")
subset <- readRDS("subset_index.rds")
load("ALL_TF.Rda")
cl <- colnames(sds@clusterLabels)[apply(sds@clusterLabels,1,which.max)]
batch <- droplevels(colData(cl2)$batch[subset])
# # data should have been quantile normalized, but wouldnt we expect all LS to be equal?
# hist(colSums(assays(cl2)$counts), breaks=100)
#
# #
# plot(density(log1p(assays(cl2)$counts[,1])), type='n')
# for(ii in 1:9) lines(density(log1p(assays(cl2)$counts[,ii])), col=ii)
#
plot3d(reducedDim(cl2)[subset,1:3], aspect = 'iso', col=brewer.pal(9,'Set1')[factor(cl)], alpha=.3)
for(i in 1:4){
rgl::plot3d(sds@curves[[i]]$s[, 1:3], type = "l", add = TRUE, lwd = 4, col = "black")
}
offsetHBC <- rep(log(1), length(subset))
# sce <- fitGAM(assays(cl2)$counts[,subset],
#               sds = sds,
# 		          U = NULL,
#               nknots = 7, offset=offsetHBC,
#               parallel = FALSE)
#saveRDS(sce, file="/home/compomics/Dropbox/compomicsVM/brainstat/hbcRegen/sce_noOffset.rds")
sce <- readRDS("sce_noOffset_noBatch.rds")
# labels for plots
labels <- c("Neur", "rHBC", "Sus", "MV")
names(labels) <- as.character(1:4)
source("~/Dropbox/research/PhD/Research/singleCell/trajectoryInference/trajectoryDE/tradeSeq/R/utils.R")
epsilon <- 1e-6
calculateDerivatives <- function(sce, gene, lineage, epsilon=1e-6, nPoints=200){
## gather all required objects
id <- which(rownames(sce) == gene)
beta <- matrix(unlist(rowData(sce)$tradeSeq$beta[id,]),ncol=1)
Sigma <- rowData(sce)$tradeSeq$Sigma[[id]]
X <- colData(sce)$tradeSeq$X
slingshotColData <- colData(sce)$slingshot
pseudotime <- slingshotColData[,grep(x = colnames(slingshotColData),
pattern = "pseudotime")]
dm <- colData(sce)$tradeSeq$dm
## calculate lp matrix with finite differencing
newd1 <- .getPredictRangeDf(dm, lineage, nPoints=nPoints)
newd2 <- newd1
newd1[,paste0("t",lineage)] <- newd1[,paste0("t",lineage)] - epsilon
X0 <- predictGAM(X, newd1, pseudotime)
newd2[,paste0("t",lineage)] <- newd2[,paste0("t",lineage)] + epsilon
X1 <- predictGAM(X, newd2, pseudotime)
Xp <- (X1-X0)/(2*epsilon) ## maps coefficients to (fd approx.) derivatives
## calculate first derivative
df <- Xp%*%beta              ## ith smooth derivative
df.sd <- rowSums(Xp%*%Sigma*Xp)^.5 ## cheap diag(Xi%*%b$Vp%*%t(Xi))^.5
dfsd <- data.frame(der=df, sdDer=df.sd)
colnames(dfsd) <- c(paste0("der",lineage), paste0("sdDer",lineage))
return(dfsd)
}
calculateDerivativesWithSigma <- function(sce, gene, lineage, epsilon=1e-6, nPoints=200){
## gather all required objects
id <- which(rownames(sce) == gene)
beta <- matrix(unlist(rowData(sce)$tradeSeq$beta[id,]),ncol=1)
Sigma <- rowData(sce)$tradeSeq$Sigma[[id]]
X <- colData(sce)$tradeSeq$X
slingshotColData <- colData(sce)$slingshot
pseudotime <- slingshotColData[,grep(x = colnames(slingshotColData),
pattern = "pseudotime")]
dm <- colData(sce)$tradeSeq$dm
## calculate lp matrix with finite differencing
newd1 <- .getPredictRangeDf(dm, lineage, nPoints=nPoints)
newd2 <- newd1
newd1[,paste0("t",lineage)] <- newd1[,paste0("t",lineage)] - epsilon
X0 <- predictGAM(X, newd1, pseudotime)
newd2[,paste0("t",lineage)] <- newd2[,paste0("t",lineage)] + epsilon
X1 <- predictGAM(X, newd2, pseudotime)
Xp <- (X1-X0)/(2*epsilon) ## maps coefficients to (fd approx.) derivatives
## calculate first derivative
df <- Xp%*%beta              ## ith smooth derivative
#df.sd <- rowSums(Xp%*%Sigma*Xp)^.5 ## cheap diag(Xi%*%b$Vp%*%t(Xi))^.5
sigmaDer <- Xp%*%Sigma%*%t(Xp)
dfsd <- list(der=df, sdDer=sigmaDer)
names(dfsd) <- c(paste0("der",lineage), paste0("sdDer",lineage))
return(dfsd)
}
plotSmoothersWithDerivatives <- function(sce, gene, counts, gridDf, derDf){
dfAll <- as.data.frame(cbind(gridDf,derDf))
cowplot::plot_grid(
#smoothers
plotSmoothers(sce, gene=gene, counts=counts, lwd=1),
ggplot(dfAll, aes(x=grid1, y=derDf$der1)) +
geom_line() +
geom_line(aes(x=grid1, y=derDf$der1 - 2*derDf$sdDer1), lty=2) +
geom_line(aes(x=grid1, y=derDf$der1 + 2*derDf$sdDer1), lty=2) +
geom_hline(yintercept=0, col="red") +
ggtitle("Neuronal lineage") +
ylab("First derivative"),
ggplot(dfAll, aes(x=grid2, y=derDf$der2)) +
geom_line() +
geom_line(aes(x=grid2, y=derDf$der2 - 2*derDf$sdDer2), lty=2) +
geom_line(aes(x=grid2, y=derDf$der2 + 2*derDf$sdDer2), lty=2) +
geom_hline(yintercept=0, col="red") +
ggtitle("rHBC lineage") +
ylab("First derivative"),
# test statistics
ggplot(dfAll, aes(x=grid1, y=derDf$der1/derDf$sdDer1)) +
geom_line() +
geom_line(aes(x=grid2, y=derDf$der2/derDf$sdDer2)) +
geom_line(aes(x=grid3, y=derDf$der3/derDf$sdDer3)) +
geom_line(aes(x=grid4, y=derDf$der4/derDf$sdDer4)) +
geom_hline(yintercept=0, col="red") +
ggtitle("Test statistics"),
ggplot(dfAll, aes(x=grid3, y=derDf$der3)) +
geom_line() +
geom_line(aes(x=grid3, y=derDf$der3 - 2*derDf$sdDer3), lty=2) +
geom_line(aes(x=grid3, y=derDf$der3 + 2*derDf$sdDer3), lty=2) +
geom_hline(yintercept=0, col="red") +
ggtitle("SUS lineage") +
ylab("First derivative"),
ggplot(dfAll, aes(x=grid4, y=derDf$der4)) +
geom_line() +
geom_line(aes(x=grid4, y=derDf$der4 - 2*derDf$sdDer4), lty=2) +
geom_line(aes(x=grid4, y=derDf$der4 + 2*derDf$sdDer4), lty=2) +
geom_hline(yintercept=0, col="red") +
ggtitle("MV lineage") +
ylab("First derivative"),
nrow=2, ncol=3
)
}
makeGSEATable <- function(overlapFile, nBP=20){
overlap <- readLines(overlapFile)
overlapSets <- overlap[10:30]
overlapSetsSplit <- sapply(overlapSets, function(x) strsplit(x, split = "\t"))
gsNames <- unname(unlist(lapply(overlapSetsSplit, "[[", 1)))
genesInSet <- unname(unlist(lapply(overlapSetsSplit, "[[", 2)))
genesInOverlap <- unname(unlist(lapply(overlapSetsSplit, "[[", 4)))
pvalUniqGam <- unname(unlist(lapply(overlapSetsSplit, "[[", 6)))
qval <- unname(unlist(lapply(overlapSetsSplit, "[[", 7)))
gsNames <- tolower(gsNames)
gsNames <- gsub(x = gsNames, pattern = "_", replacement = " ")
gsNames[-1] <- unname(sapply(gsNames[-1], function(x) substr(x, 4, nchar(x))))
tab <- data.frame(
geneSet = gsNames[-1],
overlap = as.numeric(genesInOverlap[-1]),
genesInSet = as.numeric(genesInSet[-1]),
qvalue = qval[-1]
)
#library(xtable)
#print(xtable(tab), type="html")
return(tab)
}
tf <- intersect(ALL_TF, rownames(sce))
write.table(tf, "GSEA/tfLookedAt.txt", quote=FALSE,
row.names=FALSE, col.names=FALSE)
# derAllTF <- list()
# for(ii in 1:length(tf)){
#   gene <- tf[ii]
#   derGene <- do.call(cbind, sapply(1:4, function(ll){
#     calculateDerivatives(sce=sce,
#                         gene=gene,
#                         lineage=ll)
#   }, simplify=FALSE))
#   derAllTF[[ii]] <- derGene
# }
# saveRDS(derAllTF, file="derAllTF.rds")
derAllTF <- readRDS("derAllTF.rds")
names(derAllTF) <- tf
# identify relevant pseudotime range for each lineage
dm <- colData(sce)$tradeSeq$dm
nPoints <- 200
grid1 <- tradeSeq:::.getPredictRangeDf(dm, 1, nPoints)
id1 <- which(grid1$t1 > 5 & grid1$t1 < 60)
grid2 <- tradeSeq:::.getPredictRangeDf(dm, 2, nPoints)
id2 <- which(grid2$t2 > 5 & grid2$t2 < 60)
grid3 <- tradeSeq:::.getPredictRangeDf(dm, 3, nPoints)
id3 <- which(grid3$t3 > 5 & grid3$t3 < 60)
grid4 <- tradeSeq:::.getPredictRangeDf(dm, 4, nPoints)
id4 <- which(grid4$t4 > 5 & grid4$t4 < 60)
maxDers <- matrix(NA, nrow=length(tf), ncol=4)
rownames(maxDers) <- tf
for(ii in 1:length(tf)){
gene <- tf[ii]
derTests <- sapply(1:4, function(ll){
rr <- (2*ll-1):(2*ll) #range for the lineage
stat <- derAllTF[[gene]][get(paste0("id",ll)),rr[1]] / derAllTF[[gene]][get(paste0("id",ll)),rr[2]] #test statistic
return(stat)
})
maxDers[ii,] <- unlist(lapply(derTests, max))
}
ooTF <- order(apply(maxDers,1,min), decreasing=TRUE)
# labels for plots
labels <- c("Neur", "rHBC", "Sus", "MV")
names(labels) <- as.character(1:4)
# grid object for plots
gridDf <- data.frame(grid1=grid1$t1, grid2=grid2$t2, grid3=grid3$t3,
grid4=grid4$t4)
ii <- 0
while(ii < 5){
ii <- ii+1
gene = rownames(maxDers)[ooTF[ii]]
#print(suppressMessages(plotSmoothers(sce, gene=gene, counts=assays(cl2)$counts[,subset]) +
#ggtitle(gene) +
#scale_color_viridis_d(labels=labels, alpha=1)))
print(plotSmoothersWithDerivatives(sce, gene=gene,
counts=assays(cl2)$counts[,subset],
gridDf=gridDf,
derDf=derAllTF[[gene]]))
}
setwd("~/Dropbox/research/PhD/research/singleCell/trajectoryInference/trajectoryDE/tradeSeqPaper/")
library(here)
library(slingshot)
library(RColorBrewer)
library(mgcv)
library(tradeSeq)
library(edgeR)
library(rafalib)
library(wesanderson)
library(ggplot2)
library(cowplot)
library(iCOBRA)
library(scales)
library(dplyr)
RNGversion("3.5.0")
FQnorm <- function(counts){
rk <- apply(counts,2,rank,ties.method = 'min')
counts.sort <- apply(counts,2,sort)
refdist <- apply(counts.sort,1,median)
norm <- apply(rk,2,function(r){ refdist[r] })
rownames(norm) <- rownames(counts)
return(norm)
}
### cyclic trajectory: take first dataset ####
dataAll <- readRDS(here::here("simulation", "sim2_dyngen_cycle_72/datasets/datasets_for_koen.rds"))
data <- dataAll[[1]]
counts <- t(data$counts)
pal <- wes_palette("Zissou1", 12, type = "continuous")
truePseudotime <- data$prior_information$timecourse_continuous
g <- Hmisc::cut2(truePseudotime, g = 12)
# quantile normalization
normCounts <- FQnorm(counts)
# dim red
pca <- prcomp(log1p(t(normCounts)), scale. = FALSE)
rd <- pca$x[,1:2]
plot(rd, pch = 16, asp = 1, col = pal[g])
# pc
pcc <- principal_curve(rd, smoother = "periodic_lowess")
lines(x = pcc$s[order(pcc$lambda), 1], y = pcc$s[order(pcc$lambda), 2], col = "red", lwd = 2)
rdCycle <- rd
pccCycle <- pcc
gCycle <- g
rm(data, counts, truePseudotime, g, normCounts, pca, rd, pcc)
### bifurcating dyntoy dataset ####
data <- readRDS(here("simulation", "sim2_dyntoy_bifurcating_4/datasets/20190326_dyntoyDataset_1.rds"))
counts <- t(data$counts)
pal <- wes_palette("Zissou1", 12, type = "continuous")
truePseudotime <- data$prior_information$timecourse_continuous
g <- Hmisc::cut2(truePseudotime,g = 12)
# quantile normalization
normCounts <- FQnorm(counts)
## dim red
pca <- prcomp(log1p(t(normCounts)), scale. = FALSE)
rd <- pca$x[,1:2]
plot(rd, pch = 16, asp = 1, col=pal[g])
set.seed(9)
cl <- kmeans(rd, centers = 6)$cluster
plot(rd, col = brewer.pal(9,"Set1")[cl], pch = 16, asp = 1)
legend("topleft", legend = as.character(1:7), col = brewer.pal(9, "Set1")[1:7], pch = 16, cex = 2 / 3, bty = "n")
#lineages
lin <- getLineages(rd, cl, start.clus = 3, end.clus = c(1, 2))
plot(rd, col = pal[g], pch = 16, asp = 1)
lines(lin, lwd = 2)
#curves
crv <- getCurves(lin)
plot(rd, col = pal[g], pch = 16, asp = 1)
lines(crv, lwd = 2, col = "black")
rdBif <- rd
crvBif <- crv
gBif <- g
rm(data, counts, truePseudotime, g, normCounts, pca, rd, crv, lin, cl)
#### multifurcating dataset ####
data <- readRDS(here("simulation","/sim2_dyntoy_multifurcating_4/data.rds"))
counts <- t(data$counts)
pal <- wes_palette("Zissou1", 12, type = "continuous")
truePseudotime <- data$prior_information$timecourse_continuous[colnames(counts)]
g <- Hmisc::cut2(truePseudotime, g = 12)
# quantile normalization
normCounts <- FQnorm(counts)
## dim red
pca <- prcomp(log1p(t(normCounts)), scale. = FALSE)
rd <- pca$x[,1:3]
plot(rd, pch = 16, asp = 1)
set.seed(9)
cl <- kmeans(rd, centers = 8)$cluster
plot(rd, col = brewer.pal(9, "Set1")[cl], pch = 16, asp = 1)
legend("topleft", legend = as.character(1:7), col = brewer.pal(9, "Set1")[1:7],
pch = 16, cex = 2 / 3, bty = "n")
plot(rd, col = pal[g], pch = 16, asp = 1)
#lineages
lin <- getLineages(rd, cl, start.clus = 4, end.clus = c(1, 2, 8))
plot(rd, col = pal[g], pch = 16, asp = 1)
lines(lin, lwd = 2)
#curves
crv <- getCurves(lin)
plot(rd, col = pal[g], pch = 16, asp = 1)
lines(crv, lwd = 2, col = "black")
rdMulti <- rd
crvMulti <- crv
gMulti <- g
rm(data, counts, truePseudotime, g, normCounts, pca, rd, crv, lin, cl)
### prepare performance plots ####
cols <- c(rep(c("#C6DBEF", "#08306B"), each = 3), "#4292C6", "#4daf4a",
"#e41a1c", "#e78ac3", "#ff7f00", "darkgoldenrod1")
names(cols) <- c("tradeSeq_slingshot_end", "tradeSeq_GPfates_end", "tradeSeq_Monocle2_end",
"tradeSeq_slingshot_pattern", "tradeSeq_GPfates_pattern",
"tradeSeq_Monocle2_pattern", "tradeSeq_slingshot_assoc", "Monocle3_assoc",
"BEAM", "GPfates", "edgeR", "ImpulseDE2")
linetypes <- c(rep(c("dashed", "dotdash", "solid"), 2), rep("solid", 7))
names(linetypes) <- c("tradeSeq_slingshot_end", "tradeSeq_GPfates_end", "tradeSeq_Monocle2_end",
"tradeSeq_slingshot_pattern", "tradeSeq_GPfates_pattern",
"tradeSeq_Monocle2_pattern", "tradeSeq_slingshot_assoc", "Monocle3_assoc",
"BEAM", "GPfates", "edgeR", "ImpulseDE2")
theme_set(theme_bw())
theme_update(legend.position = "none",
panel.grid.major.y = element_blank(),
panel.grid.minor.y = element_blank(),
panel.grid.major.x = element_line(linetype = "dashed", colour = "black"),
panel.grid.minor.x = element_line(linetype = "dashed", colour = "grey"),
axis.title.x = element_text(size = rel(1)),
axis.title.y = element_text(size = rel(1)),
axis.text.x = element_text(size = rel(.8)),
axis.text.y = element_text(size = rel(.8)))
### cyclic performance ####
cyclePlot <- readRDS(here("simulation", "performancePlots", "pMeanCycle_v2IncludingEdgeR.rds"))
pCycle <- cyclePlot + scale_x_continuous(limits = c(0, 0.6), breaks = c(0.01, 0.05, 0.1,.5,1),
minor_breaks = c(0:5) * .1) +
scale_y_continuous(limits = c(.5, 1)) +
scale_color_manual(values = cols, breaks = names(cols)) +
scale_linetype_manual(values = linetypes, breaks = names(linetypes))
rm(cyclePlot)
### bifurcating performance  ####
bifPlot <- readRDS(here("simulation", "performancePlots", "pMeanIstBifurcation.rds"))
pDyntoyBif <- bifPlot +
scale_x_continuous(limits = c(0, 0.6), breaks = c(0.01, 0.05, 0.1, .5, 1),
minor_breaks = c(0:5) * .1) +
scale_y_continuous(limits = c(.5, 1)) +
scale_color_manual(values = cols, breaks = names(cols)) +
scale_linetype_manual(values = linetypes, breaks = names(linetypes))
rm(bifPlot)
### multifurcating performance ####
cobraDyntoy4 <- readRDS(here("simulation", "sim2_dyntoy_multifurcating_4", "cobra.rds"))
cobraDyntoy4 <- calculate_adjp(cobraDyntoy4)
cobraDyntoy4 <- calculate_performance(cobraDyntoy4, binary_truth = "status")
multiPlot <- data.frame(FDP = cobraDyntoy4@fdrtprcurve$FDR,
TPR = cobraDyntoy4@fdrtprcurve$TPR,
method = cobraDyntoy4@fdrtprcurve$method)
pMulti <- ggplot(multiPlot, aes(x = FDP, y = TPR, col = method)) +
geom_path(size = 1, aes(linetype = method)) +
xlab("FDP") +
scale_y_continuous(limits = c(.5, 1)) +
scale_x_continuous(limits = c(0, 0.6), breaks = c(0.01, 0.05, 0.1, .5, 1),
minor_breaks = c(0:5) * .1) +
scale_color_manual(values = cols, breaks = names(cols)) +
scale_linetype_manual(values = linetypes, breaks = names(linetypes))
rm(multiPlot)
## Get a common legend ####
cobraCycle <- readRDS(here("simulation", "sim2_dyngen_cycle_72", "datasets", "cobra1.rds"))
pval(cobraCycle) <- pval(cobraCycle)[,c("tradeSeq_slingshot_assoc", "Monocle3")]
colnames(pval(cobraCycle))[2] <- "Monocle3_assoc"
cobraCycle <- calculate_adjp(cobraCycle)
cobraCycle <- calculate_performance(cobraCycle, binary_truth = "status")
CyclePlot <- data.frame(FDP = cobraCycle@fdrtprcurve$FDR,
TPR = cobraCycle@fdrtprcurve$TPR,
method = cobraCycle@fdrtprcurve$method)
cobraBif <- readRDS(here("simulation", "sim2_dyntoy_bifurcating_4", "datasets", "cobra1.rds"))
colnames(pval(cobraBif)) = gsub(colnames(pval(cobraBif)), pattern="tradeR",replacement="tradeSeq")
cobraBif <- calculate_adjp(cobraBif)
cobraBif <- calculate_performance(cobraBif, binary_truth = "status")
bifPlot <- data.frame(FDP = cobraBif@fdrtprcurve$FDR,
TPR = cobraBif@fdrtprcurve$TPR,
method = cobraBif@fdrtprcurve$method)
pAll <- ggplot(full_join(CyclePlot, bifPlot),
aes(x = FDP, y = TPR, col = method)) +
geom_path(size = 1, aes(linetype = method)) +
scale_color_manual(values = cols, breaks = names(cols)) +
scale_linetype_manual(values = linetypes, breaks = names(linetypes))
legend_all <- get_legend(pAll + labs(col = "", linetype = "") +
theme(legend.position = "bottom",
legend.key.width = unit(1.3, "cm")) +
guides(col=guide_legend(nrow=3)))
### composite plot ####
ggCycle <- ggplot(as.data.frame(rdCycle), aes(x = PC1, y = PC2)) +
geom_point(col = pal[gCycle]) +
theme_classic() +
geom_path(x = pccCycle$s[order(pccCycle$lambda), 1],
y = pccCycle$s[order(pccCycle$lambda), 2]) +
ggtitle("Cyclic dataset") +
theme(plot.title = element_text(face = "bold", hjust = .5))
ggBif <- ggplot(as.data.frame(rdBif), aes(x = PC1, y = PC2)) +
geom_point(col = pal[gBif]) +
theme_classic() +
geom_path(x = crvBif@curves$curve1$s[crvBif@curves$curve1$ord, 1],
y = crvBif@curves$curve1$s[crvBif@curves$curve1$ord, 2]) +
geom_path(x = crvBif@curves$curve2$s[crvBif@curves$curve2$ord, 1],
y = crvBif@curves$curve2$s[crvBif@curves$curve2$ord, 2]) +
ggtitle("Bifurcating dataset") +
theme(plot.title = element_text(face = "bold", hjust = .5))
ggMulti <- ggplot(as.data.frame(rdMulti), aes(x = PC1, y = PC2)) +
geom_point(col = pal[gMulti]) +
theme_classic() +
geom_path(x = crvMulti@curves$curve1$s[crvMulti@curves$curve1$ord, 1],
y = crvMulti@curves$curve1$s[crvMulti@curves$curve1$ord, 2]) +
geom_path(x = crvMulti@curves$curve2$s[crvMulti@curves$curve2$ord, 1],
y = crvMulti@curves$curve2$s[crvMulti@curves$curve2$ord, 2]) +
geom_path(x = crvMulti@curves$curve3$s[crvMulti@curves$curve3$ord, 1],
y = crvMulti@curves$curve3$s[crvMulti@curves$curve3$ord, 2]) +
ggtitle("Multifurcating dataset") +
theme(plot.title = element_text(face = "bold", hjust = .5))
p1 <- plot_grid(ggCycle + coord_fixed(),
ggdraw() +
draw_image("~/Dropbox/research/PhD/research/singleCell/trajectoryInference/trajectoryDE/plots/wesandersonColorLegendVertical.png",
scale = 1),
ggBif + coord_fixed(), NULL,
ggMulti + coord_fixed(),
pCycle + coord_fixed(), NULL,
pDyntoyBif + coord_fixed(), NULL,
pMulti + coord_fixed(),
nrow = 2, ncol = 5, rel_heights = c(0.8, 1),
rel_widths = c(1, 0.3, 1, 0.3, 1),
labels = c("a", "", "b", "", "c", "d", "", "e", "", "f")
)
p1
detach("package:ggplot2", unload=TRUE)
