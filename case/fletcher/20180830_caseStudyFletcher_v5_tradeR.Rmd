---
title: 'Case study: OE dataset'
author: "Koen Van den Berge"
date: "`r Sys.Date()`"
---

# pca data

```{r loadPCAData}
load("~/PhD_Data/singleCell/fletcher/ShareWithKelly/E4c2b_slingshot_wsforkelly.RData")
library(slingshot)
library(rgl)
library(rafalib)
mypar()
library(RColorBrewer)
library(mgcv)
library(tradeSeq)

origData <- t(pcax$x %*% t(pcax$rotation))
colpal <- cc
rd <- X[, 1:5]
lin <- getLineages(rd, clusterLabels = clus.labels, start.clus = "1", end.clus = "4")
crv <- getCurves(lin)
plot(X[, 1:2], col = colpal[as.factor(clus.labels)], pch = 16)
lines(crv)
# 3D plot
rgl::plot3d(X[, 1:3], t = "p", col = colpal[as.factor(clus.labels)], alpha = 0.3, pch = 19, cex = 2, size = 8, xlab = "PC 1", ylab = "PC 2", zlab = "PC 3", aspect = "iso", box = FALSE, axes = FALSE)
# rgl::plot3d(X[,1:3], t='p', col=c("white","black")[hlp+1],alpha=0.3, pch = 19, cex = 2, size=8, xlab="PC 1", ylab="PC 2", zlab="PC 3", aspect="iso", box=FALSE, axes=FALSE)
rgl::axes3d(tick = FALSE)
rgl::par3d(windowRect = c(20, 30, 800, 800))
for (i in seq_along(curves)) {
  rgl::plot3d(crv@curves[[i]]$s[order(crv@curves[[i]]$lambda), 1:3], type = "l", add = TRUE, lwd = 4, col = colpal[which.max(tail(lin@lineages[[i]], 1) == levels(clus.labels))])
}
rgl::plot3d(20, 90, 0, col = "black", add = TRUE)


# rgl.postscript("~/fletcher3d.pdf", fmt="pdf")
```

In the plot below, trajectory 1 (neuronal trajectory) is the green curve, trajectory 2 is the yellow curve, and trajectory 3 (sustentacular trajectory) is the brown curve.

```{r plot1, echo=TRUE, fig.cap="Fletcher 3D PCA", include=identical(knitr:::pandoc_to(), 'html')}
knitr::include_graphics("/Users/koenvandenberge/fletcher3d.pdf")
#![Fletcher 3D PCA](/Users/koenvandenberge/fletcher3d.pdf)
```

```{r cufflinksCountData}
suppressPackageStartupMessages(library(SummarizedExperiment))
load("~/Downloads/GSE95601_oeHBCdiff_Cufflinks_eSet.rda")
counts <- assayData(Cufflinks_eSet)$counts_table
counts <- counts[!apply(counts, 1, function(row) any(is.na(row))), ]
counts <- counts[, colnames(counts) %in% colnames(origData)]
keep <- rowSums(edgeR::cpm(counts) > 5) >= 15
countsFiltered <- counts[keep, ]
countsFiltered <- countsFiltered[-grep(rownames(countsFiltered), pattern="ERCC"),]
```

```{r EDA}
# batch from Github
library(scone)
library(edgeR)
load("~/p63-HBC-diff/output/clust/oeHBCdiff/oeHBCdiff_scone.Rda")
batch <- droplevels(colData(scone_out)$batch[match(colnames(countsFiltered), rownames(colData(scone_out)))])
run <- droplevels(phenoData(Cufflinks_eSet)[[3]])[colnames(exprs(Cufflinks_eSet)) %in% colnames(origData)]
# table(batch,run)
```

# fit smoothers on unaligned data

## get ZI weights from zinbwave

```{r zinbwave}
library(zinbwave)
library(BiocParallel)
library(doParallel)
NCORES <- 2
registerDoParallel(NCORES)
register(DoparParam())

core <- SummarizedExperiment(countsFiltered, colData = data.frame(clusLabel = clus.labels, batch = batch))
#zinb_c <- zinbFit(core, X = '~ clusLabel + batch', commondispersion = TRUE)

#save(zinb_c,file="~/zinbFletcherTradeSeq.rda")
load("~/zinbFletcherTradeSeq.rda")
weights <- computeObservationalWeights(zinb_c, countsFiltered)

```


```{r fitGAM}
#gamList <- tradeSeq::fitGAM(countsFiltered, U=model.matrix(~-1+batch), pseudotime=slingPseudotime(crv, na=FALSE), cellWeights=slingCurveWeights(crv), weights=weights)
#save(gamList,file="~/gamListOE_tradeSeq.rda")
load("~/gamListOE_tradeSeq.rda")
## check convergence
converged <- unlist(lapply(gamList, function(m){
  if(class(m)=="try-error"){
    return(FALSE)
  } else return(m$converged)
}))
mean(converged)
sum(converged) ; length(gamList)
```


# BETWEEN LINEAGE COMPARISONS

## Comparing the expression at the differentiated cell type

```{r}
endTestGam <- diffEndTest(gamList, global = TRUE, pairwise = TRUE)
endOmnibusPval <- endTestGam$pvalue
sum(is.na(endOmnibusPval)) # genes we could not fit or test.
endOmnibusPadj <- p.adjust(endOmnibusPval, "fdr")
sum(endOmnibusPadj <= 0.05, na.rm = TRUE)
mean(endOmnibusPadj <= 0.05, na.rm = TRUE)
deGenesEndGam <- which(endOmnibusPadj <= 0.05)
hist(endOmnibusPval)
```

# edgeR analysis

In the edgeR analysis, I compare the gene expression of the differentiated cell types (i.e. final cluster of a trajectory) to each other, between the different trajectories.

```{r}
library(edgeR)
d <- DGEList(countsFiltered)
d <- calcNormFactors(d)
design <- model.matrix(~clus.labels+batch)
d$weights <- weights
d <- estimateDisp(d,design)
fit <- glmFit(d,design)
L <- matrix(0, nrow = ncol(fit$coefficients), ncol = 3)
rownames(L) <- colnames(fit$coefficients)
# trajectory 1 vs. 2
L[c("clus.labels12", "clus.labels15"), 1] <- c(1, -1)
# trajectory 3 vs 1
L[c("clus.labels4", "clus.labels12"), 2] <- c(1, -1)
# trajectory 3 vs 2
L[c("clus.labels4", "clus.labels15"), 3] <- c(1, -1)
lrt <- zinbwave::glmWeightedF(fit, contrast = L)
deGenesEdgeR <- which(p.adjust(lrt$table$PValue, "fdr") <= 0.05)
length(deGenesEdgeR)
mean(deGenesEdgeR %in% deGenesEndGam)
hist(lrt$table$PValue)
```

# compare analyses

We retrieve 85% of the genes that edgeR finds, but also obtain a bunch of other genes.

```{r}
mypar(mfrow=c(1,1))

## compare
edgeRDE <- p.adjust(lrt$table$PValue, "fdr") <= 0.05
gamDE <- endOmnibusPadj <= 0.05
vennC <- cbind(edgeRDE, gamDE)
vennDiagram(vennC, main = "end point comparison across all trajectories")
```

# plot unique GAM genes

```{r}
uniqueGamEndId <- which(gamDE == TRUE & edgeRDE == FALSE)

i <- 0
while (i < 10) {
  i <- i + 1
  plotSmoothers(gamList[[uniqueGamEndId[i]]])
}
```

# plot unique edgeR genes

```{r}
uniqueEdgeREndId <- which(gamDE == FALSE & edgeRDE == TRUE)

i <- 0
while (i < 10) {
  i <- i + 1
  plotSmoothers(gamList[[uniqueEdgeREndId[i]]])
}
```

# are unique GAM genes relevant?

```{r}
uniqGamEndFletcher <- rownames(countsFiltered)[uniqueGamEndId]
write.table(uniqGamEndFletcher, file = "~/uniqGamEndFletcher.txt", row.names = FALSE, col.names = FALSE, quote = FALSE)
# submit to http://software.broadinstitute.org/gsea/msigdb/compute_overlaps.jsp for top 20 gene sets
overlapUniqEndGam <- readLines("~/Dropbox/PhD/Research/singleCell/trajectoryInference/trajectoryDE/tradeSeqPaper/case/fletcher/overlapUniqGamEndFletcher")
overlapSets <- overlapUniqEndGam[10:30]
overlapSetsSplit <- sapply(overlapSets, function(x) strsplit(x, split = "\t"))
gsNames <- unname(unlist(lapply(overlapSetsSplit, "[[", 1)))
genesInSet <- unname(unlist(lapply(overlapSetsSplit, "[[", 2)))
genesInOverlap <- unname(unlist(lapply(overlapSetsSplit, "[[", 4)))
qval <- unname(unlist(lapply(overlapSetsSplit, "[[", 7)))
gsNames <- tolower(gsNames)
gsNames <- gsub(x = gsNames, pattern = "_", replacement = " ")
gsNames[-1] <- unname(sapply(gsNames[-1], function(x) substr(x, 4, nchar(x))))
tab <- data.frame(
  geneSet = gsNames[-1],
  overlap = genesInOverlap[-1],
  genesInSet = genesInSet[-1],
  qvalue = qval[-1]
)
library(xtable)
xtable(tab)

```



```{r patternTest}
resPat <- patternTest(gamList, global = TRUE, pairwise = TRUE)
o <- order(resPat$waldStat, decreasing = TRUE)

i <- 0
while (i < 10) {
  i <- i + 1
  plotSmoothers(gamList[[o[i]]], main = i)
}

# for paper
source("~/Dropbox/PhD/Research/singleCell/trajectoryInference/trajectoryDE/tradeSeqPaper/case/fletcher/plotSmoothersFletcher.R")
library(scales)
png("~/Dropbox/PhD/Research/singleCell/trajectoryInference/trajectoryDE/plots/topGenesFletcherPattern.png", width = 6, height = 7, units = "in", res = 300)
mypar(mfrow = c(3, 2))
i <- 0
while (i < 6) {
  i <- i + 1
  plotSmoothersIk(gamList[[o[i]]], main = rownames(resPat)[o][i])
}
dev.off()

# Stage-wise testing
library(stageR)
pScreen <- resPat$pvalue
names(pScreen) <- rownames(resPat)
pConfirmation <- cbind(resPat$pvalue_1vs2, resPat$pvalue_1vs3, resPat$pvalue_2vs3)
dimnames(pConfirmation) <- list(rownames(resPat), c("1v2", "1v3", "2v3"))
stageObj <- stageR(pScreen, pConfirmation, pScreenAdjusted = FALSE)
stageObj <- stageWiseAdjustment(stageObj, alpha = .05, method = "holm", allowNA = TRUE)
res <- getResults(stageObj)
colSums(res)
allCompGenes <- names(which(rowSums(res) == 4))
write.table(allCompGenes, file = "~/allCompGenes.txt", row.names = FALSE, col.names = FALSE, quote = FALSE)
# submit these in http://software.broadinstitute.org/gsea/msigdb/compute_overlaps.jsp

overlap <- readLines("~/Dropbox/PhD/Research/singleCell/trajectoryInference/trajectoryDE/overlapCellCycleOE")
overlapSets <- overlap[10:30]
overlapSetsSplit <- sapply(overlapSets, function(x) strsplit(x, split = "\t"))
gsNames <- unname(unlist(lapply(overlapSetsSplit, "[[", 1)))
genesInSet <- unname(unlist(lapply(overlapSetsSplit, "[[", 2)))
genesInOverlap <- unname(unlist(lapply(overlapSetsSplit, "[[", 4)))
qval <- unname(unlist(lapply(overlapSetsSplit, "[[", 7)))
gsNames <- tolower(gsNames)
gsNames <- gsub(x = gsNames, pattern = "_", replacement = " ")
gsNames[-1] <- unname(sapply(gsNames[-1], function(x) substr(x, 4, nchar(x))))
tab <- data.frame(
  geneSet = gsNames[-1],
  overlap = genesInOverlap[-1],
  genesInSet = genesInSet[-1],
  qvalue = qval[-1]
)
# library(xtable)
# xtable(tab)

# cluster fitted values of genes significant for pattern test and create a heatmap.
# or plot gene clusters their smoothing profiles
log(fitted(gamList[[1]]) + .1)
```


# within lineage comparisons

### cell cycle patterns within lineages: edgeR

```{r cellCycleWithin}
plot(x = levels(clus.labels), pch = 16, col = colpal)
# colors 5,7,4 are last three clusters of SUS lineage
# colors 2,14,10,9,11 are last 5 clusters of NEUR lineage
# colors 1, 8, 5, 3, 2,14,10,9,11 are all clusters of NEUR lineage

L <- matrix(0, nrow = ncol(fit$coefficients), ncol = 9)
rownames(L) <- colnames(fit$coefficients)
colnames(L) <- crv@lineages[[1]]
L[c("clus.labels8", "clus.labels5", "clus.labels3", "clus.labels2", "clus.labels14", "clus.labels10", "clus.labels9", "clus.labels11"), 1] <- rep(-1 / 8, 8)
L[c("clus.labels8", "clus.labels5", "clus.labels3", "clus.labels2", "clus.labels14", "clus.labels10", "clus.labels9", "clus.labels11"), 2] <- c(1, rep(-1 / 8, 7))
L[c("clus.labels8", "clus.labels5", "clus.labels3", "clus.labels2", "clus.labels14", "clus.labels10", "clus.labels9", "clus.labels11"), 3] <- c(-1, 1, rep(-1 / 8, 6))
L[c("clus.labels8", "clus.labels5", "clus.labels3", "clus.labels2", "clus.labels14", "clus.labels10", "clus.labels9", "clus.labels11"), 4] <- c(rep(-1 / 8, 2), 1, rep(-1 / 8, 5))
L[c("clus.labels8", "clus.labels5", "clus.labels3", "clus.labels2", "clus.labels14", "clus.labels10", "clus.labels9", "clus.labels11"), 5] <- c(rep(-1 / 8, 3), 1, rep(-1 / 8, 4))
L[c("clus.labels8", "clus.labels5", "clus.labels3", "clus.labels2", "clus.labels14", "clus.labels10", "clus.labels9", "clus.labels11"), 6] <- c(rep(-1 / 8, 4), 1, rep(-1 / 8, 3))
L[c("clus.labels8", "clus.labels5", "clus.labels3", "clus.labels2", "clus.labels14", "clus.labels10", "clus.labels9", "clus.labels11"), 7] <- c(rep(-1 / 8, 5), 1, rep(-1 / 8, 2))
L[c("clus.labels8", "clus.labels5", "clus.labels3", "clus.labels2", "clus.labels14", "clus.labels10", "clus.labels9", "clus.labels11"), 8] <- c(rep(-1 / 8, 6), 1, rep(-1 / 8, 1))
L[c("clus.labels8", "clus.labels5", "clus.labels3", "clus.labels2", "clus.labels14", "clus.labels10", "clus.labels9", "clus.labels11"), 9] <- c(rep(-1 / 8, 7), 1)
lrtList <- list()
for (i in 1:ncol(L)) lrtList[[i]] <- zinbwave::glmWeightedF(fit, contrast = L[, i])


cellGenes <- read.table("~/Downloads/GO_term_summary_20181001_091947.txt", header = TRUE, sep = "\t", row.names = NULL)
cellGenes$MGI.Gene.Marker.ID <- as.character(cellGenes$MGI.Gene.Marker.ID)
mean(cellGenes$MGI.Gene.Marker.ID %in% rownames(counts))
mean(cellGenes$MGI.Gene.Marker.ID %in% rownames(countsFiltered))
sum(cellGenes$MGI.Gene.Marker.ID %in% rownames(countsFiltered))

sumFoundMat <- matrix(NA, nrow = nrow(countsFiltered), ncol = 9)
for (i in 1:length(lrtList)) {
  pvals <- lrtList[[i]]$table$PValue
  o <- order(pvals)
  pvalsO <- pvals[o]
  namesO <- rownames(lrtList[[i]])[o]
  sumFound <- sapply(1:nrow(countsFiltered), function(ii) {
    sum(cellGenes$MGI.Gene.Marker.ID %in% namesO[1:ii])
  })
  sumFoundMat[, i] <- sumFound
}

# aggregate cluster comparisons
library(aggregation)
pvalMatEdgeR <- do.call(cbind, lapply(lrtList, function(x) x$table$PValue))
fisherP <- apply(pvalMatEdgeR, 1, fisher)
names(fisherP) <- rownames(lrtList[[1]]$table)
o <- order(fisherP)
sumFoundFisher <- sapply(1:nrow(countsFiltered), function(ii) {
  sum(cellGenes$MGI.Gene.Marker.ID %in% names(fisherP[o])[1:ii])
})
```

### cell cycle patterns within lineages: tradeSeq associationTest

```{r}
assocRes <- associationTest(gamList, global = TRUE, lineages = TRUE)
deAssoc1 <- rownames(assocRes)[p.adjust(assocRes$pvalue_1, "fdr") <= 0.05]
deAssoc1 <- deAssoc1[!is.na(deAssoc1)]
length(deAssoc1) # 1951 DE genes

o = order(assocRes$waldStat_1, decreasing=TRUE)
write.table(head(assocRes[o,"waldStat_1",drop=FALSE], 2000), file="~/topGenesNeuronalLineage.txt", quote=FALSE, col.names=FALSE)
```

#### cell cycle gene set

```{r}
cellGenes <- read.table("~/Downloads/GO_term_summary_20181001_091947.txt", header = TRUE, sep = "\t", row.names = NULL)
cellGenes$MGI.Gene.Marker.ID <- as.character(cellGenes$MGI.Gene.Marker.ID)
cellGenes <- cellGenes[cellGenes$MGI.Gene.Marker.ID %in% rownames(countsFiltered), ]
# out of a total of 2889 genes present in filtered dataset
sum(cellGenes$MGI.Gene.Marker.ID %in% deAssoc1)

# make enrichment plot
# how many cell cycle genes were discovered along ordering of significance?
o <- order(assocRes$waldStat_1, decreasing = TRUE)
sumFoundCC <- sapply(1:nrow(assocRes), function(ii) {
  sum(cellGenes$MGI.Gene.Marker.ID %in% rownames(assocRes)[o[1:ii]], na.rm = TRUE)
})
# how many do we expect by chance?
sumFoundRandom <- (nrow(cellGenes) / nrow(assocRes)) * (1:nrow(assocRes))
# absolute
plot(x = 1:nrow(assocRes), y = sumFoundCC, type = "l")
lines(x = 1:nrow(assocRes), y = (2889 / nrow(assocRes)) * (1:nrow(assocRes)), type = "l", col = "steelblue")
expRandom <- (2889 / nrow(smootherStats)) * (1:nrow(smootherStats))
# relative
plot(x = 1:nrow(assocRes), y = sumFoundCC / sumFoundRandom, type = "l", ylab = "# genes found with tradeSeq / # genes found under random selection")
abline(h = 1, lty = 2, col = "red")


png("~/Dropbox/PhD/Research/singleCell/trajectoryInference/trajectoryDE/plots/cellCycleFletcher.png", width = 7, height = 7, units = "in", res = 200)
plot(x = 1:nrow(assocRes), y = sumFoundCC / sumFoundRandom, type = "l", ylab = "# genes found with tradeSeq / # genes found under random selection", bty = "n", xlab = "Gene list ordered according to significance", col = "darkgray", lwd = 1.5)
abline(h = 1, lty = 2, col = "red")
dev.off()
```


#### Heatmap of top genes

```{r}
o1 <- order(assocRes[deAssoc1, "waldStat_1"], decreasing = TRUE)
top200Assoc <- deAssoc1[o1[1:200]]

# heatmap for neuronal lineage.
source("/Users/koenvandenberge/Dropbox/PhD/Research/singleCell/trajectoryInference/trajectoryDE/tradeSeq/R/utils.R")
df <- .getPredictRangeDf(gamList[[1]], lineageId = 1, nPoints = 100)
y <- do.call(rbind, lapply(gamList[top200Assoc], predict, newdata = df, type = "link"))
yScaled <- t(scale(t(y)))
pst <- slingPseudotime(crv)
pst <- cbind(pst, clus.labels)
pst <- pst[!is.na(pst[, 1]), ]
pst <- pst[order(pst[, 1], decreasing = FALSE), ]

df$ct <- NA
df$cols <- NA
df$ct[df$t1 < 80] <- "HBC"
df$cols[df$t1 < 80] <- colpal[1]
# df$ct[df$t1>=80 & df$t1<115] <- expression(paste(Delta, "HBC1"))
df$ct[df$t1 >= 80 & df$t1 < 115] <- "HBC1"
df$cols[df$t1 >= 80 & df$t1 < 115] <- colpal[3]
# df$ct[df$t1>=90 & df$t1<100] <- expression(paste(Delta, "HBC2"))
df$ct[df$t1 >= 90 & df$t1 < 100] <- "HBC2"
df$cols[df$t1 >= 90 & df$t1 < 100] <- colpal[6]
df$ct[df$t1 >= 115 & df$t1 < 220] <- "GBC"
df$cols[df$t1 >= 115 & df$t1 < 220] <- colpal[17]
df$ct[df$t1 >= 220 & df$t1 < 250] <- "INP1"
df$cols[df$t1 >= 220 & df$t1 < 250] <- colpal[24]
df$ct[df$t1 >= 250 & df$t1 < 310] <- "INP2"
df$cols[df$t1 >= 250 & df$t1 < 310] <- colpal[4]
df$ct[df$t1 >= 310 & df$t1 < 325] <- "INP3"
df$cols[df$t1 >= 310 & df$t1 < 325] <- colpal[19]
df$ct[df$t1 >= 325 & df$t1 < 385] <- "iOSN"
df$cols[df$t1 >= 325 & df$t1 < 385] <- colpal[13]
df$ct[df$t1 >= 385] <- "mOSN"
df$cols[df$t1 >= 385] <- colpal[8]

library(pheatmap)
annoCol <- data.frame(celltype = df$ct)
rownames(annoCol) <- colnames(yScaled)
dfUniq <- unique(df[, c("ct", "cols")])
colhlp <- dfUniq$cols
names(colhlp) <- dfUniq$ct
annColors <- list(celltype = colhlp)
heatRaw <- pheatmap(yScaled, cluster_cols = FALSE, show_rownames = FALSE, show_colnames = FALSE, cutree_rows = 5, clustering.method = "ward.D", annotation_col = annoCol, annotation_colors = annColors, annotation_names_col = FALSE)

## reorder big clusters.
library(vegan)
set.seed(7)
origHClust <- heatRaw$tree_row
hlpClust <- function(hc, mat) {
  reorder(hc, wts = runif(200))
}
pheatmap(yScaled, cluster_cols = FALSE, show_rownames = FALSE, show_colnames = FALSE, cutree_rows = 5, clustering.method = "ward.D", annotation_col = annoCol, annotation_colors = annColors, annotation_names_col = FALSE, clustering_callback = hlpClust)
```

# Cell cycle functional annotation


 pattern contrast between neuronal and sustentacular lineage should reveal cell cycle genes, since the cells in neuronal lineage undergo cell division, while the sustentacular lineage cells do not. Also this occurs in intermediary stages, and not at end stage, so we need the pattern test for this.
  cell cycle gene set: http://www.informatics.jax.org/go/term/GO:0007049
 downloaded on October 1st 2018


```{r cc}
cellGenes <- read.table("~/Downloads/GO_term_summary_20181001_091947.txt", header = TRUE, sep = "\t", row.names = NULL)
cellGenes$MGI.Gene.Marker.ID <- as.character(cellGenes$MGI.Gene.Marker.ID)
mean(cellGenes$MGI.Gene.Marker.ID %in% rownames(counts))


# we expect the cell cycle genes to have different patterns but to not be DE at end point.
plot(x = log(endTestGam$waldStat_1vs3), y = log(resPat$waldStat_1vs3))
# note that Wald stats are not directly comparable due to df.
plot(x = endTestGam$waldStat_1vs3, y = resPat$waldStat_1vs3 / resPat$df_1vs3, log = "xy")
abline(0, 1, col = "red")
# compare p-values:
logit <- function(x) log(x / (1 - x))
plot(x = logit(endTestGam$pvalue_1vs3), y = logit(resPat$pvalue1vs3), pch = 16, cex = 2 / 3)

# code from vignette, written by Hector:
library(dplyr)
compare <- inner_join(resPat %>%
  mutate(
    Gene = rownames(resPat),
    pattern = waldStat_1vs3
  ) %>%
  select(Gene, pattern),
endTestGam %>%
  mutate(
    Gene = rownames(endTestGam),
    end = waldStat_1vs3
  ) %>%
  select(Gene, end),
by = c("Gene" = "Gene")
) %>%
  mutate(transientScore = (min_rank(desc(end)))^2 +
    (min_rank(pattern) - 1)^2)
library(ggplot2)
ggplot(compare, aes(x = log(pattern), y = log(end))) +
  geom_point(aes(col = transientScore)) +
  labs(
    x = "endPointTest Wald Statistic (log scale)",
    y = "patternTest Wald Statistic (log scale)"
  ) +
  scale_color_continuous(low = "yellow", high = "red") +
  theme_classic()

topTransient <- (compare %>% arrange(desc(transientScore)))



sumFoundtradeSeq <- sapply(1:nrow(countsFiltered), function(ii) {
  sum(cellGenes$MGI.Gene.Marker.ID %in% topTransient$Gene[1:ii])
})


## get range of cluster comparisons to check if the tradeSeq analysis improves upon ANY cluster comparison
# in PCA plot, col=colpal[as.factor(clus.labels)]
plot(x = levels(clus.labels), pch = 16, col = colpal)
# colors 5,7,4 are last three clusters of SUS lineage
# colors 2,14,10,9,11 are last 5 clusters of NEUR lineage
L <- matrix(0, nrow = ncol(fit$coefficients), ncol = 15)
rownames(L) <- colnames(fit$coefficients)
L[c("clus.labels5", "clus.labels2"), 1] <- c(1, -1)
L[c("clus.labels5", "clus.labels14"), 2] <- c(1, -1)
L[c("clus.labels5", "clus.labels10"), 3] <- c(1, -1)
L[c("clus.labels5", "clus.labels9"), 4] <- c(1, -1)
L[c("clus.labels5", "clus.labels11"), 5] <- c(1, -1)
L[c("clus.labels7", "clus.labels2"), 6] <- c(1, -1)
L[c("clus.labels7", "clus.labels14"), 7] <- c(1, -1)
L[c("clus.labels7", "clus.labels10"), 8] <- c(1, -1)
L[c("clus.labels7", "clus.labels9"), 9] <- c(1, -1)
L[c("clus.labels7", "clus.labels11"), 10] <- c(1, -1)
L[c("clus.labels4", "clus.labels2"), 11] <- c(1, -1)
L[c("clus.labels4", "clus.labels14"), 12] <- c(1, -1)
L[c("clus.labels4", "clus.labels10"), 13] <- c(1, -1)
L[c("clus.labels4", "clus.labels9"), 14] <- c(1, -1)
L[c("clus.labels4", "clus.labels11"), 15] <- c(1, -1)
lrtList <- list()
for (i in 1:ncol(L)) lrtList[[i]] <- zinbwave::glmWeightedF(fit, contrast = L[, i])



sumFoundMat <- matrix(NA, nrow = nrow(countsFiltered), ncol = 15)
for (i in 1:length(lrtList)) {
  pvals <- lrtList[[i]]$table$PValue
  o <- order(pvals)
  pvalsO <- pvals[o]
  namesO <- rownames(lrtList[[i]])[o]
  sumFound <- sapply(1:nrow(countsFiltered), function(ii) {
    sum(cellGenes$MGI.Gene.Marker.ID %in% namesO[1:ii])
  })
  sumFoundMat[, i] <- sumFound
}


o <- order(endTestGam$waldStat_1vs3, decreasing = TRUE)
sumFoundEnd <- sapply(1:nrow(countsFiltered), function(ii) {
  sum(cellGenes$MGI.Gene.Marker.ID %in% rownames(endTestGam[o, ])[1:ii])
})

o <- order(resPat$waldStat_1vs3, decreasing = TRUE)
sumFoundPat <- sapply(1:nrow(countsFiltered), function(ii) {
  sum(cellGenes$MGI.Gene.Marker.ID %in% rownames(resPat[o, ])[1:ii])
})


library(aggregation)
pvalMatEdgeR <- do.call(cbind, lapply(lrtList, function(x) x$table$PValue))
fisherP <- apply(pvalMatEdgeR, 1, fisher)
names(fisherP) <- rownames(lrtList[[1]]$table)
o <- order(fisherP)
sumFoundFisher <- sapply(1:nrow(countsFiltered), function(ii) {
  sum(cellGenes$MGI.Gene.Marker.ID %in% names(fisherP[o])[1:ii])
})

library(scales)
plot(x = 1:nrow(countsFiltered), y = sumFoundPat, type = "l", log = "y", col = "darkseagreen3", lwd = 2)
# lines(x=1:nrow(countsFiltered), y=sumFoundEnd, col="red")
lines(x = 1:nrow(countsFiltered), y = sumFoundFisher, col = "red", lwd = 2)
for (i in 1:15) lines(x = 1:nrow(countsFiltered), y = sumFoundMat[, i], col = alpha(colorRampPalette(c("lightblue", "darkblue"))(15)[i], .5))


# we can also do a pattern test on a fixed region...
# first check which cluster comparisons are performing that good.
# 1, 6, 11 are performing best. Note that all of these involve a comparison of the INP1 cluster with the three other SUS clusters. Hence, it is this cluster that matters; the differences are local and this is thus probably not a good example.
```


# Check for HBC markers

```{r}
startRes <- startVsEndTest(gamList)
top250Genes <- rownames(head(startRes[order(startRes$waldStat, decreasing = TRUE), ], 250))
write.table(top250Genes, file = "~/startTestOETop250_tradeSeq.txt", row.names = FALSE, col.names = FALSE, quote = FALSE)
# submit to http://software.broadinstitute.org/gsea/msigdb/compute_overlaps.jsp for top 20 gene sets


overlap <- readLines("~/Dropbox/PhD/Research/singleCell/trajectoryInference/trajectoryDE/overlapStartTestOE_tradeSeq")
overlapSets <- overlap[10:30]
overlapSetsSplit <- sapply(overlapSets, function(x) strsplit(x, split = "\t"))
gsNames <- unname(unlist(lapply(overlapSetsSplit, "[[", 1)))
genesInSet <- unname(unlist(lapply(overlapSetsSplit, "[[", 2)))
genesInOverlap <- unname(unlist(lapply(overlapSetsSplit, "[[", 4)))
qval <- unname(unlist(lapply(overlapSetsSplit, "[[", 7)))
gsNames <- tolower(gsNames)
gsNames <- gsub(x = gsNames, pattern = "_", replacement = " ")
gsNames[-1] <- unname(sapply(gsNames[-1], function(x) substr(x, 4, nchar(x))))
tab <- data.frame(
  geneSet = gsNames[-1],
  overlap = genesInOverlap[-1],
  genesInSet = genesInSet[-1],
  qvalue = qval[-1]
)
# library(xtable)
# xtable(tab)
```



#### early DE test


```{r}
early24 <- earlyDETest(gamList, knots = c(2, 4), nPoints = 50, global = TRUE, pairwise = TRUE)
library(stageR)
pScreen <- early24$pvalue
names(pScreen) <- rownames(countsFiltered)
pConfirmation <- cbind(early24$pvalue_1vs2, early24$pvalue_1vs3, early24$pvalue_2vs3)
rownames(pConfirmation) <- rownames(countsFiltered)
colnames(pConfirmation) <- c("1v2", "1v3", "2v3")
stageRObj <- stageR(pScreen = pScreen, pConfirmation = pConfirmation, pScreenAdjusted = FALSE)
stageRObj <- stageWiseAdjustment(stageRObj, method = "holm", alpha = 0.05, allowNA = TRUE)
res <- getResults(stageRObj)
sigAll24 <- names(which(rowSums(res) == 4))
# most of these genes seem to be very relevant.
# https://www.genecards.org/cgi-bin/carddisp.pl?gene=FREM1
# Cenpf and Cdca8 are about cell cycle

library(UpSetR)
resDf <- as.data.frame(res)
colnames(resDf) <- c("Global", "Neur. vs. Microv.", "Neur. vs. Sust.", "Microv. vs. Sust.")
upset(resDf[, -1], order.by = "freq", text.scale = c(1.3, 1.3, 1, 1, 2, 1))


plotSmoothersIk <- function(m, nPoints = 100, ...) {
  data <- m$model
  y <- data$y
  # construct time variable based on cell assignments.
  nCurves <- length(m$smooth)
  timeAll <- c()
  col <- c()
  for (jj in seq_len(nCurves)) {
    for (ii in 1:nrow(data)) {
      if (data[ii, paste0("l", jj)] == 1) {
        timeAll[ii] <- data[ii, paste0("t", jj)]
        col[ii] <- jj
      } else {
        next
      }
    }
  }

  # plot raw data
  # cols <- c("#E7298A", "#FF7F00", "#1F78B4")
  cols <- c("#FF7F00", "#1F78B4", "#E7298A")
  plot(
    x = timeAll, y = log(y + 1), col = alpha(cols[col], 2 / 3), pch = 16, cex = 2 / 3,
    ylab = "log(count + 1)", xlab = "Pseudotime", ...
  )

  # predict and plot smoothers across the range
  for (jj in seq_len(nCurves)) {
    df <- .getPredictRangeDf(m, jj, nPoints = nPoints)
    yhat <- predict(m, newdata = df, type = "response")
    lines(x = df[, paste0("t", jj)], y = log(yhat + 1), col = cols[jj], lwd = 2)
  }
  # knots
  abline(v = gamList[[1]]$smooth[[1]]$xp[2], lty = 2, col = "black", lwd = 1.5)
  abline(v = gamList[[1]]$smooth[[1]]$xp[4], lty = 2, col = "black", lwd = 1.5)
  legend("topleft", c("Neuronal", "Microvillous", "Sustentacular"),
    col = cols,
    lty = 1, lwd = 2, bty = "n", cex = 4 / 5
  )
}
library(scales)
png("~/Dropbox/PhD/Research/singleCell/trajectoryInference/trajectoryDE/plots/earlyDE24SignGenesInAll.png", width = 9, height = 7, units = "in", res = 200)
rafalib::mypar(mfrow = c(3, 3), bty = "l")
for (ii in 1:9) {
  plotSmoothersIk(gamList[[sigAll24[ii]]], ylim = c(0, 10), main = sigAll24[ii])
}
dev.off()

png("~/Dropbox/PhD/Research/singleCell/trajectoryInference/trajectoryDE/plots/earlyDE24SignGenesInAll_allGenes.png", width = 9, height = 7, units = "in", res = 200)
rafalib::mypar(mfrow = c(4, 4), bty = "l")
for (ii in 1:length(sigAll24)) {
  plotSmoothersIk(gamList[[sigAll24[ii]]], ylim = c(0, 10), main = sigAll24[ii])
}
dev.off()


# neuronal vs sus lineage
sum(p.adjust(early24$pvalue_1vs3, "fdr") <= 0.05, na.rm = TRUE) # 588 genes
# microvillous vs sus lineage
sum(p.adjust(early24$pvalue_2vs3, "fdr") <= 0.05, na.rm = TRUE) # 452 genes
# neuronal vs microvillous lineage
sum(p.adjust(early24$pvalue_1vs2, "fdr") <= 0.05, na.rm = TRUE) # 258 genes
```

# plot for paper v2

```{r}
plotSmoothersIk <- function(m, nPoints = 100, ...) {
  data <- m$model
  y <- data$y
  # construct time variable based on cell assignments.
  nCurves <- length(m$smooth)
  timeAll <- c()
  col <- c()
  for (jj in seq_len(nCurves)) {
    for (ii in 1:nrow(data)) {
      if (data[ii, paste0("l", jj)] == 1) {
        timeAll[ii] <- data[ii, paste0("t", jj)]
        col[ii] <- jj
      } else {
        next
      }
    }
  }

  # plot raw data
  # cols <- c("#E7298A", "#FF7F00", "#1F78B4")
  cols <- c("#FF7F00", "#1F78B4", "#E7298A")
  plot(
    x = timeAll, y = log(y + 1), col = alpha(cols[col], 2 / 3), pch = 16, cex = 2 / 3,
    ylab = "log(count + 1)", xlab = "Pseudotime", ...
  )

  # predict and plot smoothers across the range
  for (jj in seq_len(nCurves)) {
    df <- .getPredictRangeDf(m, jj, nPoints = nPoints)
    yhat <- predict(m, newdata = df, type = "response")
    lines(x = df[, paste0("t", jj)], y = log(yhat + 1), col = cols[jj], lwd = 2)
  }
  # knots
  abline(v = gamList[[1]]$smooth[[1]]$xp[2], lty = 2, col = "black", lwd = 1.5)
  abline(v = gamList[[1]]$smooth[[1]]$xp[4], lty = 2, col = "black", lwd = 1.5)
  legend("topleft", c("Neuronal", "Microvillous", "Sustentacular"),
    col = cols,
    lty = 1, lwd = 2, bty = "n", cex = 4 / 5
  )
}

## heatmap
png("~/Dropbox/PhD/Research/singleCell/trajectoryInference/trajectoryDE/plots/FigCaseFletcher_heatmap.png", width = 7, height = 6, units = "in", res = 200)
## reorder big clusters.
set.seed(7)
origHClust <- heatRaw$tree_row
hlpClust <- function(hc, mat) {
  stats::reorder(origHClust, wts = runif(200))
}
pheatmap(yScaled, cluster_cols = FALSE, show_rownames = FALSE, show_colnames = FALSE, cutree_rows = 5, clustering.method = "ward.D", annotation_col = annoCol, annotation_colors = annColors, annotation_names_col = FALSE, clustering_callback = hlpClust)
dev.off()

### early DE genes
library(scales)
png("~/Dropbox/PhD/Research/singleCell/trajectoryInference/trajectoryDE/plots/FigCaseFletcher_earlyDE.png", width = 7, height = 6, units = "in", res = 200)
rafalib::mypar(mfrow = c(2, 2))
for (ii in c(1, 2, 4, 5)) {
  plotSmoothersIk(gamList[[sigAll24[ii]]], ylim = c(0, 10), main = sigAll24[ii])
}
dev.off()

```


# Session information

```{r}
sessionInfo()
```
