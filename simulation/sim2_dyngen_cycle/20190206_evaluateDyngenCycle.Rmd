---
title: "evaluate methods on second generation simulation: cyclic trajectory"
author: "Koen Van den Berge"
date: "6 February 2019"
output: html_document
---

```{r data}
library(slingshot)
library(RColorBrewer)
library(mgcv)
library(tradeR)
library(edgeR)
library(rafalib)
library(wesanderson)

data=readRDS("~/Dropbox/PhD/Research/singleCell/trajectoryInference/trajectoryDE/tradeRPaper/simulation/sim2_dyngen_cycle/80.rds")
counts <- t(data$counts)
falseGenes <- data$feature_info$gene_id[!data$feature_info$housekeeping]
nullGenes <- data$feature_info$gene_id[data$feature_info$housekeeping]

pal <- wes_palette("Zissou1", 12, type = "continuous")
truePseudotime <- data$prior_information$timecourse_continuous
g <- Hmisc::cut2(truePseudotime,g=12)

# quantile normalization
FQnorm <- function(counts){
  rk <- apply(counts,2,rank,ties.method='min')
  counts.sort <- apply(counts,2,sort)
  refdist <- apply(counts.sort,1,median)
  norm <- apply(rk,2,function(r){ refdist[r] })
  rownames(norm) <- rownames(counts)
  return(norm)
}
normCounts <- FQnorm(counts)

## dim red
pca <- prcomp(log1p(t(normCounts)), scale. = FALSE)
rd <- pca$x[,1:2]
plot(rd, pch=16, asp = 1)

library(princurve)
pcc <- principal_curve(rd, smoother="periodic_lowess")
lines(x=pcc$s[order(pcc$lambda),1], y=pcc$s[order(pcc$lambda),2], col="red", lwd=2)
```

# fit smoothers on raw data

```{r}
cWeights <- matrix(1,nrow=ncol(counts),ncol=1)
pseudoT <- matrix(pcc$lambda,nrow=ncol(counts),ncol=1)
gamList <- fitGAM(counts, pseudotime=pseudoT, cellWeights=cWeights, verbose=TRUE)
```

# Test for differences at end point

```{r}
endRes <- diffEndTest(gamList)
hist(endRes$pvalue)
deGenesEndGam <- rownames(counts)[which(p.adjust(endRes$pvalue,"fdr")<=0.05)]
mean(falseGenes%in%deGenesEndGam) #TPR
mean(!deGenesEndGam%in%falseGenes) #FDR
```

# edgeR analysis on final clusters

```{r}
clF <- as.factor(cl)
design <- model.matrix(~clF)

library(edgeR)
d <- DGEList(counts)
d <- calcNormFactors(d)
d <- estimateDisp(d, design)
fit <- glmFit(d, design)
lrt <- glmLRT(fit, coef="clF2") #cluster 2 vs cluster 1 (end clusters)
deGenesEdgeR <- rownames(lrt$table)[p.adjust(lrt$table$PValue,"fdr")<=0.05]
mean(falseGenes%in%deGenesEdgeR) #TPR
mean(deGenesEdgeR%in%nullGenes) #FDR
```

# compare GAM end point vs edgeR analysis

```{r}
library(rafalib)
mypar(mfrow=c(1,1))

## compare
edgeRDE <- p.adjust(lrt$table$PValue,"fdr")<=0.05
gamDE <- p.adjust(endRes$pval,"fdr")<=0.05
vennC <- cbind(edgeRDE,gamDE)
vennDiagram(vennC, main="end point comparison across all trajectories")
```

# Test for different expression pattern

```{r}
resPattern <- patternTest(gamList)
hist(resPattern$pval)
deGenesPattern <- rownames(counts)[which(p.adjust(resPattern$pval,"fdr")<=0.05)]
length(deGenesPattern)
mean(falseGenes%in%deGenesPattern) #TPR
mean(!deGenesPattern%in%falseGenes) #FDR

```

# Monocle BEAM analysis

```{r}
### old monocle BEAM analysis
library(monocle,lib.loc="~/Dropbox/PhD/Research/singleCell/trajectoryInference/trajectoryDE/methodsPaper/")
featureInfo <- data.frame(gene_short_name=rownames(counts))
rownames(featureInfo) <- rownames(counts)
fd <- new("AnnotatedDataFrame", featureInfo)
cds <- newCellDataSet(cellData=counts, featureData=fd, expressionFamily=negbinomial.size())
cds <- estimateSizeFactors(cds)
cds <- estimateDispersions(cds)
cds <- reduceDimension(cds, max_components = 4, method = 'ICA')
cds <- orderCells(cds, num_paths=2)
plot_cell_trajectory(cds, color_by = "State")
# monocle does not find a branching point on 2 components! specify 4.
BEAM_res <- BEAM(cds,  cores = 1)
sum(BEAM_res$qval<0.05)
```

# tradeR on true time and weights

```{r}
### tradeR on true pseudotime
pst <- matrix(truePseudotime, nrow=ncol(counts),ncol=2, byrow=FALSE)
gamListTrueTime <- fitGAM(counts, pseudotime=pst, cellWeights=slingCurveWeights(crv), verbose=TRUE)
# end point test
waldEndPointResTrueTime <- diffEndTest(gamListTrueTime)
padjWaldTrueTime <- p.adjust(waldEndPointResTrueTime$pvalue,"fdr")
sum(padjWaldTrueTime<=0.05)
# pattern test
patternResTrueTime <- patternTest(gamListTrueTime)
padjPatternTrueTime <- p.adjust(patternResTrueTime$pvalue,"fdr")
sum(padjPatternTrueTime<=0.05, na.rm=TRUE)

```

# GPfates

```{r}
# export
logCpm <- edgeR::cpm(counts, prior.count=.125, log=TRUE)
sampleInfo <- data.frame(global_pseudotime=truePseudotime)
rownames(sampleInfo) <- colnames(counts)
write.table(logCpm, file="~/Dropbox/PhD/Research/singleCell/trajectoryInference/trajectoryDE/tradeRPaper/simulation/sim2_dyntoy/simDyntoyLogCpm.txt", row.names=TRUE, col.names=TRUE, quote=FALSE)
write.table(sampleInfo, file="~/Dropbox/PhD/Research/singleCell/trajectoryInference/trajectoryDE/tradeRPaper/simulation/sim2_dyntoy/sampleInfoSimDyntoy.txt", row.names=TRUE, col.names=TRUE, quote=FALSE)
# run with 20190206_runGPfates_simDyntoy.py
GPfatesWeights <- read.table("~/Dropbox/PhD/Research/singleCell/trajectoryInference/trajectoryDE/tradeRPaper/simulation/sim2_dyntoy/GPfatesWeights.txt", header=FALSE)
GPfatesBif <- read.table("~/Dropbox/PhD/Research/singleCell/trajectoryInference/trajectoryDE/tradeRPaper/simulation/sim2_dyntoy/GPfatesBifStats.txt", header=FALSE)
colnames(GPfatesBif) <- c("bif_ll", "amb_ll", "shuff_bif_ll", "shuff_amb_ll", "phi0_corr", "D", "shuff_D")
```

# GPfates weights + tradeR

```{r}
# based on true pseudotime
gamListGPfatesTrueTime <- fitGAM(counts, pseudotime=pst, cellWeights=GPfatesWeights, verbose=TRUE)
# end point test
waldEndPointResTrueTimeGPfates <- diffEndTest(gamListGPfatesTrueTime)
# pattern test
patternResTrueTimeGPfates <- patternTest(gamListGPfatesTrueTime)
```

# Performance plots

```{r}
########
# FDP-TPR
########
library(iCOBRA)
library(scales)
truth <- as.data.frame(matrix(rep(0,nrow(counts)), dimnames=list(rownames(counts),"status")))
truth[falseGenes,"status"] <- 1
cols <- hue_pal()(8)
names(cols) <- c("BEAM", "GPfates", "edgeR", "tradeR_slingshot_end", "tradeR_slingshot_pattern", "tradeR_GPfates_end", "tradeR_GPfates_pattern")

### estimated pseudotime
pval <- data.frame( tradeR_slingshot_end=endRes$pval,
                    tradeR_slingshot_pattern=resPattern$pval,
                    BEAM=BEAM_res$pval,
                    edgeR=lrt$table$PValue,
                      row.names=rownames(counts))
cobra <- COBRAData(pval=pval, truth=truth)
cobra <- calculate_adjp(cobra)
cobra <- calculate_performance(cobra, binary_truth="status")
cobraplot <- prepare_data_for_plot(cobra, colorscheme=cols[match(sort(unique(cobra@roc$method)),names(cols))])
plot_roc(cobraplot)
plot_fdrtprcurve(cobraplot, pointsize=3/2, yaxisrange=c(0.8,1))
pEst <- plot_fdrtprcurve(cobraplot, pointsize=3/2, yaxisrange=c(0.8,1), xaxisrange=c(0,0.5))


### true pseudotime
pval <- data.frame( tradeR_slingshot_end=waldEndPointResTrueTime$pval,
                    tradeR_slingshot_pattern=patternResTrueTime$pval,
                    BEAM=BEAM_res$pval,
                    edgeR=lrt$table$PValue,
                    tradeR_GPfates_end=waldEndPointResTrueTimeGPfates$pval,
                    tradeR_GPfates_pattern=patternResTrueTimeGPfates$pval,
                      row.names=rownames(counts))
score <- data.frame(GPfates=GPfatesBif$D,
                      row.names=rownames(counts))
cobra <- COBRAData(pval=pval, truth=truth, score=score)
cobra <- calculate_adjp(cobra)
cobra <- calculate_performance(cobra, binary_truth="status")
cobraplot <- prepare_data_for_plot(cobra, colorscheme=cols[match(sort(unique(cobra@roc$method)),names(cols))])
plot_roc(cobraplot)
plot_fdrtprcurve(cobraplot, pointsize=3/2, yaxisrange=c(0.8,1), xaxisrange=c(0,0.5))
pTrue <- plot_fdrtprcurve(cobraplot, pointsize=3/2, yaxisrange=c(0.8,1), xaxisrange=c(0,0.5))
#
library(cowplot)
prow <- plot_grid( pEst + theme(legend.position="none") + xlab("FDP") + ggtitle("Based on estimated pseudotime"),
           pTrue + theme(legend.position="none") + xlab("FDP") + ggtitle("Based on true pseudotime"),
           align = 'vh',
           labels = c("a", "b"),
           hjust = -1,
           nrow = 1
           )
legend_a <- get_legend(pTrue + theme(legend.position="bottom"))
p <- plot_grid( prow, legend_a, ncol = 1, rel_heights = c(1, .2))
p

#png("~/Dropbox/PhD/Research/singleCell/trajectoryInference/trajectoryDE/plots/performanceSim1.png", width=7,height=6, units="in", res=300)
# p
# dev.off()
#
# #composite one plot
# pval <- data.frame( tradeR_slingshot_end=endRes$pval,
#                     tradeR_slingshot_pattern=resPattern$pval,
#                     BEAM=BEAM_res$pval,
#                     edgeR=lrt$table$PValue,
#                     tradeR_GPfates_end=waldEndPointResTrueTimeGPfates$pval,
#                     tradeR_GPfates_pattern=patternResTrueTimeGPfates$pval,
#                       row.names=rownames(counts))
# score <- data.frame(GPfates=GPfatesBif$D,
#                       row.names=rownames(counts))
# cobra <- COBRAData(pval=pval, truth=truth, score=score)
# cobra <- calculate_adjp(cobra)
# cobra <- calculate_performance(cobra, binary_truth="status")
# cobraplot <- prepare_data_for_plot(cobra, colorscheme=cols[match(sort(unique(cobra@roc$method)),names(cols))])
# plot_roc(cobraplot)
# plot_fdrtprcurve(cobraplot, pointsize=3/2, yaxisrange=c(0.8,1), xaxisrange=c(0,0.5))
# pAll <- plot_fdrtprcurve(cobraplot, pointsize=3/2, yaxisrange=c(0.8,1), xaxisrange=c(0,0.5))
# png("~/Dropbox/PhD/Research/singleCell/trajectoryInference/trajectoryDE/plots/performanceSim1All.png", width=7,height=6, units="in", res=300)
# pAll
# dev.off()
```
