grid <- seq(min(meds), max(meds), length=200)
lines(x=grid,y=predict(mBeta$gam, newdata=data.frame(gc=grid)),
col="red", lwd=2)
}
}
source("~/Dropbox/research/atacseq/method/gcqn_testing.R")
countsBulkLogisticGCQN <- logisticGCQNIk2_allSamples(counts=countsBulk, gcContent = gcBulk, nGroups=20, plot=TRUE)
source("~/Dropbox/research/atacseq/method/gcqn_testing.R")
countsBulkLogisticGCQN <- logisticGCQNIk2_allSamples(counts=countsBulk, gcContent = gcBulk, nGroups=20, plot=TRUE)
warnings()
source("~/Dropbox/research/atacseq/method/gcqn_testing.R")
countsBulkLogisticGCQN <- logisticGCQNIk2_allSamples(counts=countsBulk, gcContent = gcBulk, nGroups=20, plot=TRUE)
head(countsBulkLogisticGCQNOriginal) ; head(countsBulkLogisticGCQN)
par(mfrow=c(1,1))
plot(density(log1p(countsBulkLogisticGCQN[,1])))
for(ii in 2:ncol(countsBulk)) lines(density(log1p(countsBulkLogisticGCQN[,ii])), col=ii)
##
pal <- wesanderson::wes_palette("Zissou1", n=20, type='continuous')
plot(x=countsBulkLogisticGCQN[,1]+1, y=countsBulkLogisticGCQNOriginal[,1]+1, log="xy", pch=16, col=pal[gcgBulk]) ; abline(0,1, col="red", lwd=3/2, lty=2)
fitBulkContgcqn <- runEdgeR(countsBulkLogisticGCQN, designBulk, tmm=FALSE)
lrtBulkContgcqn <- glmLRT(fitBulkContgcqn, coef="regionAggGZ")
lfcBulkContgcqn <- fitBulkContgcqn$coefficients[,"regionAggGZ"]
deIdBulkContgcqn <- which(p.adjust(lrtBulkContgcqn$table$PValue, "fdr") <= 0.05)
mypar(mfrow=c(1,1))
boxplot(lfcBulkContgcqn~gcgBulk, main="Bulk, Continuous GC-QN corrected") ; abline(h=0, col="red", lty=2, lwd=2)
betaMat <- matrix(NA, nrow=nlevels(gcgBulk), ncol=4)
meds <- c()
betaList <- list()
for(jj in 1:ncol(countsBulk)){
for(ii in 1:nlevels(gcgBulk)){
#message(ii)
id <- which(gcgBulk==levels(gcgBulk)[ii])
meds[ii] <- median(gcBulk[id])
countBin <- countsBulk[id,jj,drop=FALSE]
betaEst <- logisticFQnormIk_beta(countBin, type='median', plot=FALSE, min.quant=0.01, max.quant=0.99)
betaMat[ii,] <- betaEst
}
betaList[[jj]] <- betaMat
}
betaMat <- matrix(NA, nrow=nlevels(gcgBulk), ncol=4)
meds <- c()
betaList <- list()
for(jj in 1:ncol(countsBulk)){
for(ii in 1:nlevels(gcgBulk)){
#message(ii)
id <- which(gcgBulk==levels(gcgBulk)[ii])
meds[ii] <- median(gcBulk[id])
countBin <- countsBulk[id,jj,drop=FALSE]
betaEst <- suppressWarnings(logisticFQnormIk_beta(countBin, type='median', plot=FALSE, min.quant=0.01, max.quant=0.99))
betaMat[ii,] <- betaEst
}
betaList[[jj]] <- betaMat
}
#
# modelList <- list()
# pal <- wesanderson::wes_palette("Zissou1", 20, "continuous")
# plot(x=c(-4,4), y=c(0,1), type='n', xlab="Centered log median count",
#      ylab="Quantile")
# for(ii in 1:nlevels(gcgBulk)){
#   # profvis::pause(1)
#   id <- which(gcgBulk == levels(gcgBulk)[ii])
#   countsBin <- countsBulk[id,]
#   countSorted <- apply(countsBin,2,sort)
#   medianCount <- apply(countSorted,1,median)
#   logMedianCount <- log1p(medianCount)
#   meanLogMedianCount <- mean(logMedianCount)
#   logMedianCount <- logMedianCount - meanLogMedianCount
#   quants <- ppoints(1:length(logMedianCount))
#   model <- glm(quants ~ logMedianCount + I(logMedianCount^2) + I(logMedianCount^3),
#              family = binomial(link="logit"))
#   modelList[[ii]] <- model
#   grid <- seq(-4, 4, length.out=200)
#   yhat <- predict(model, newdata=data.frame(logMedianCount=grid),
#                         type="response")
#   lines(x=grid, y=yhat, col=pal[ii], lwd=2)
# }
library(rafalib)
logisticFQnormIk_beta_rmd <- function(counts, type="median", plot=TRUE, interval=c(-5,5),
min.quant=0.01, max.quant=0.99){
## input are counts for a specific GC bin.
countSorted <- apply(as.matrix(counts),2,sort)
if(type=="median"){
medianCount <- apply(countSorted,1,median)
} else if(type=="mean"){
medianCount <- apply(countSorted,1,mean)
}
logMedianCount <- log(medianCount+1)
meanLogMedianCount <- mean(logMedianCount)
logMedianCount <- logMedianCount - meanLogMedianCount
o <- order(logMedianCount)
quants <- ppoints(1:length(medianCount))
mMedian <- glm(quants ~ logMedianCount + I(logMedianCount^2) + I(logMedianCount^3), family=binomial(link = "logit"))
betaVector <- coef(mMedian)
grid <- seq(-4, 4, length.out=200)
yhat <- predict(mMedian, newdata=data.frame(logMedianCount = grid), type="response")
return(list(betaEst=betaVector, yhat=yhat))
}
pal <- wesanderson::wes_palette("Zissou1", 20, "continuous")
mypar(mfrow=c(3,2))
betaMat <- matrix(NA, nrow=nlevels(gcgBulk), ncol=4)
meds <- c()
betaList <- list()
grid <- seq(-4, 4, length.out=200)
for(jj in 1:ncol(countsBulk)){
plot(x=grid, y=seq(0,1,length.out=200), type='n', main=paste0("sample ",jj))
for(ii in 1:nlevels(gcgBulk)){
#message(ii)
id <- which(gcgBulk==levels(gcgBulk)[ii])
meds[ii] <- median(gcBulk[id])
countBin <- countsBulk[id,jj,drop=FALSE]
binRes <- suppressWarnings(logisticFQnormIk_beta_rmd(countBin, type='median', plot=FALSE, min.quant=0.01, max.quant=0.99))
betaMat[ii,] <- binRes$betaEst
lines(x=grid, y=binRes$yhat, col=pal[ii])
}
betaList[[jj]] <- betaMat
}
pal <- wesanderson::wes_palette("Zissou1", 20, "continuous")
mypar(mfrow=c(3,2))
betaMat <- matrix(NA, nrow=nlevels(gcgBulk), ncol=4)
meds <- c()
betaList <- list()
grid <- seq(-4, 4, length.out=200)
for(jj in 1:ncol(countsBulk)){
plot(x=grid, y=seq(0,1,length.out=200), type='n', main=paste0("sample ",jj))
for(ii in 1:nlevels(gcgBulk)){
#message(ii)
id <- which(gcgBulk==levels(gcgBulk)[ii])
meds[ii] <- median(gcBulk[id])
countBin <- countsBulk[id,jj,drop=FALSE]
binRes <- suppressWarnings(logisticFQnormIk_beta_rmd(countBin, type='median', plot=FALSE, min.quant=0.01, max.quant=0.99))
betaMat[ii,] <- binRes$betaEst
lines(x=grid, y=binRes$yhat, col=pal[ii])
}
betaList[[jj]] <- betaMat
}
plot <- TRUE
medsModel <- rep(meds, ncol(countsBulk))
ss <- as.factor(rep(1:ncol(countsBulk), each=nlevels(gcgBulk)))
betaEstCont <- matrix(NA, nrow=nrow(countsBulk), ncol=4)
if(plot) par(mfrow=c(1,4))
for(jj in 1:4){
# betaHlp <- betaMat[,jj]
betaHlp <- unlist(lapply(betaList, function(x) x[,jj]))
df <- data.frame(beta=betaHlp, gc=medsModel, sample=ss)
mBeta <- gamm4::gamm4(beta ~ s(gc), random = ~(1|sample), data=df)
betaEstCont[,jj] <- predict(mBeta$gam, newdata=data.frame(gc=gcContent),
type="response")
if(plot){
plot(x=meds, y=betaList[[1]][,jj], type='n',
ylim=range(unlist(lapply(betaList, function(x) x[,jj]))),
main=colnames(betaList[[1]])[jj], xlim=range(meds))
for(kk in 1:ncol(counts)){
coefHlp <- betaList[[kk]][,jj]
lines(x=meds, y=coefHlp, type='b', col=kk)
}
grid <- seq(min(meds), max(meds), length=200)
lines(x=grid,y=predict(mBeta$gam, newdata=data.frame(gc=grid)),
col="red", lwd=2)
}
}
plot <- TRUE
names <- c("Intercept", "Linear", "Quadratic", "Cubic")
medsModel <- rep(meds, ncol(countsBulk))
ss <- as.factor(rep(1:ncol(countsBulk), each=nlevels(gcgBulk)))
betaEstCont <- matrix(NA, nrow=nrow(countsBulk), ncol=4)
if(plot) par(mfrow=c(1,4))
for(jj in 1:4){
# betaHlp <- betaMat[,jj]
betaHlp <- unlist(lapply(betaList, function(x) x[,jj]))
df <- data.frame(beta=betaHlp, gc=medsModel, sample=ss)
mBeta <- gamm4::gamm4(beta ~ s(gc), random = ~(1|sample), data=df)
betaEstCont[,jj] <- predict(mBeta$gam, newdata=data.frame(gc=gcContent),
type="response")
if(plot){
plot(x=meds, y=betaList[[1]][,jj], type='n',
ylim=range(unlist(lapply(betaList, function(x) x[,jj]))),
main=names[jj], xlim=range(meds))
for(kk in 1:ncol(counts)){
coefHlp <- betaList[[kk]][,jj]
lines(x=meds, y=coefHlp, type='b', col=kk)
}
grid <- seq(min(meds), max(meds), length=200)
lines(x=grid,y=predict(mBeta$gam, newdata=data.frame(gc=grid)),
col="red", lwd=2)
}
}
plot <- TRUE
names <- c("Intercept", "Linear", "Quadratic", "Cubic")
medsModel <- rep(meds, ncol(countsBulk))
ss <- as.factor(rep(1:ncol(countsBulk), each=nlevels(gcgBulk)))
betaEstCont <- matrix(NA, nrow=nrow(countsBulk), ncol=4)
if(plot) par(mfrow=c(1,4))
for(jj in 1:4){
# betaHlp <- betaMat[,jj]
betaHlp <- unlist(lapply(betaList, function(x) x[,jj]))
df <- data.frame(beta=betaHlp, gc=medsModel, sample=ss)
mBeta <- gamm4::gamm4(beta ~ s(gc), random = ~(1|sample), data=df)
betaEstCont[,jj] <- predict(mBeta$gam, newdata=data.frame(gc=gcContent),
type="response")
if(plot){
plot(x=meds, y=betaList[[1]][,jj], type='n',
ylim=range(unlist(lapply(betaList, function(x) x[,jj]))),
main=names[jj], xlim=range(meds))
for(kk in 1:ncol(counts)){
coefHlp <- betaList[[kk]][,jj]
lines(x=meds, y=coefHlp, type='b', col=kk)
}
grid <- seq(min(meds), max(meds), length=200)
lines(x=grid,y=predict(mBeta$gam, newdata=data.frame(gc=grid)),
col="red", lwd=2)
}
}
rm(list=ls())
library(rafalib)
df <- read.csv("~/data/atac/geschwind2018_GSE95023/GSE95023_readswithinpeaks.csv.gz")
counts <- df[,-c(1:3)]
gr <- GRanges(seqnames=df$CHR, ranges=IRanges(df$START, df$END), strand="*", mcols=counts)
ff <- FaFile("~/data/genomes/human/Homo_sapiens.GRCh37.75.dna_sm.primary_assembly.fa")
peakSeqs <- getSeq(x=ff, gr)
gcBulk <- letterFrequency(peakSeqs, "GC",as.prob=TRUE)[,1]
gcgBulk <- Hmisc::cut2(gcBulk, g=20)
# design
patient <- factor(c(rep("A",7), rep("B",6), rep("C",6)))
region <- factor(c(rep("GZ",4), rep("CP",3), rep("GZ",3), rep("CP",3), rep("GZ",3), rep("CP",3)))
# aggregate technical replicates
patReg <- paste0(patient,region)
aggDes <- model.matrix(~0 + patReg)
countsBulk <- as.matrix(counts) %*% aggDes
patientAgg <- factor(rep(c("A", "B", "C"), each=2))
regionAgg <- factor(rep(c("CP", "GZ"),3))
designBulk <- model.matrix(~patientAgg+regionAgg)
rm(df, counts, design, peakSeqs)
logisticFQnormIk_beta_rmd <- function(counts, type="median", plot=TRUE, interval=c(-5,5),
min.quant=0.01, max.quant=0.99){
## input are counts for a specific GC bin.
countSorted <- apply(as.matrix(counts),2,sort)
if(type=="median"){
medianCount <- apply(countSorted,1,median)
} else if(type=="mean"){
medianCount <- apply(countSorted,1,mean)
}
logMedianCount <- log(medianCount+1)
meanLogMedianCount <- mean(logMedianCount)
logMedianCount <- logMedianCount - meanLogMedianCount
o <- order(logMedianCount)
quants <- ppoints(1:length(medianCount))
mMedian <- glm(quants ~ logMedianCount + I(logMedianCount^2) + I(logMedianCount^3), family=binomial(link = "logit"))
betaVector <- coef(mMedian)
grid <- seq(-4, 4, length.out=200)
yhat <- predict(mMedian, newdata=data.frame(logMedianCount = grid), type="response")
return(list(betaEst=betaVector, yhat=yhat))
}
knitr::include_graphics('./gcCpmNgaiLomvardas.png')
countSorted <- apply(countsBulk,2,sort)
medianCount <- apply(countSorted,1,median)
logMedianCount <- log1p(medianCount)
meanLogMedianCount <- mean(logMedianCount)
logMedianCount <- logMedianCount - meanLogMedianCount
quants <- ppoints(1:length(logMedianCount))
plot(y = quants, x = logMedianCount, xlab="Centered log median count",
ylab = "Quantile")
model <- glm(quants ~ logMedianCount + I(logMedianCount^2) + I(logMedianCount^3),
family = binomial(link="logit"))
grid <- seq(min(logMedianCount), max(logMedianCount), length.out=200)
lines(x=grid, y=predict(model, newdata=data.frame(logMedianCount=grid),
type="response"), col="red", lwd=2)
legend("topleft", legend="Estimate", lty=1, col="red", lwd=2, bty='n')
pal <- wesanderson::wes_palette("Zissou1", 20, "continuous")
mypar(mfrow=c(3,2))
betaMat <- matrix(NA, nrow=nlevels(gcgBulk), ncol=4)
meds <- c()
betaList <- list()
grid <- seq(-4, 4, length.out=200)
for(jj in 1:ncol(countsBulk)){
plot(x=grid, y=seq(0,1,length.out=200), type='n', main=paste0("sample ",jj))
for(ii in 1:nlevels(gcgBulk)){
#message(ii)
id <- which(gcgBulk==levels(gcgBulk)[ii])
meds[ii] <- median(gcBulk[id])
countBin <- countsBulk[id,jj,drop=FALSE]
binRes <- suppressWarnings(logisticFQnormIk_beta_rmd(countBin, type='median', plot=FALSE, min.quant=0.01, max.quant=0.99))
betaMat[ii,] <- binRes$betaEst
lines(x=grid, y=binRes$yhat, col=pal[ii])
}
betaList[[jj]] <- betaMat
}
plot <- TRUE
names <- c("Intercept", "Linear", "Quadratic", "Cubic")
medsModel <- rep(meds, ncol(countsBulk))
ss <- as.factor(rep(1:ncol(countsBulk), each=nlevels(gcgBulk)))
betaEstCont <- matrix(NA, nrow=nrow(countsBulk), ncol=4)
if(plot) par(mfrow=c(1,4))
for(jj in 1:4){
# betaHlp <- betaMat[,jj]
betaHlp <- unlist(lapply(betaList, function(x) x[,jj]))
df <- data.frame(beta=betaHlp, gc=medsModel, sample=ss)
mBeta <- gamm4::gamm4(beta ~ s(gc), random = ~(1|sample), data=df)
betaEstCont[,jj] <- predict(mBeta$gam, newdata=data.frame(gc=gcContent),
type="response")
if(plot){
plot(x=meds, y=betaList[[1]][,jj], type='n',
ylim=range(unlist(lapply(betaList, function(x) x[,jj]))),
main=names[jj], xlim=range(meds))
for(kk in 1:ncol(counts)){
coefHlp <- betaList[[kk]][,jj]
lines(x=meds, y=coefHlp, type='b', col=kk)
}
grid <- seq(min(meds), max(meds), length=200)
lines(x=grid,y=predict(mBeta$gam, newdata=data.frame(gc=grid)),
col="red", lwd=2)
}
}
library(rafalib)
df <- read.csv("~/data/atac/geschwind2018_GSE95023/GSE95023_readswithinpeaks.csv.gz")
counts <- df[,-c(1:3)]
gr <- GRanges(seqnames=df$CHR, ranges=IRanges(df$START, df$END), strand="*", mcols=counts)
ff <- FaFile("~/data/genomes/human/Homo_sapiens.GRCh37.75.dna_sm.primary_assembly.fa")
peakSeqs <- getSeq(x=ff, gr)
gcBulk <- letterFrequency(peakSeqs, "GC",as.prob=TRUE)[,1]
gcgBulk <- Hmisc::cut2(gcBulk, g=20)
# design
patient <- factor(c(rep("A",7), rep("B",6), rep("C",6)))
region <- factor(c(rep("GZ",4), rep("CP",3), rep("GZ",3), rep("CP",3), rep("GZ",3), rep("CP",3)))
# aggregate technical replicates
patReg <- paste0(patient,region)
aggDes <- model.matrix(~0 + patReg)
countsBulk <- as.matrix(counts) %*% aggDes
patientAgg <- factor(rep(c("A", "B", "C"), each=2))
regionAgg <- factor(rep(c("CP", "GZ"),3))
designBulk <- model.matrix(~patientAgg+regionAgg)
rm(df, counts, design, peakSeqs)
logisticFQnormIk_beta_rmd <- function(counts, type="median", plot=TRUE, interval=c(-5,5),
min.quant=0.01, max.quant=0.99){
## input are counts for a specific GC bin.
countSorted <- apply(as.matrix(counts),2,sort)
if(type=="median"){
medianCount <- apply(countSorted,1,median)
} else if(type=="mean"){
medianCount <- apply(countSorted,1,mean)
}
logMedianCount <- log(medianCount+1)
meanLogMedianCount <- mean(logMedianCount)
logMedianCount <- logMedianCount - meanLogMedianCount
o <- order(logMedianCount)
quants <- ppoints(1:length(medianCount))
mMedian <- glm(quants ~ logMedianCount + I(logMedianCount^2) + I(logMedianCount^3), family=binomial(link = "logit"))
betaVector <- coef(mMedian)
grid <- seq(-4, 4, length.out=200)
yhat <- predict(mMedian, newdata=data.frame(logMedianCount = grid), type="response")
return(list(betaEst=betaVector, yhat=yhat))
}
knitr::include_graphics('./gcCpmNgaiLomvardas.png')
countSorted <- apply(countsBulk,2,sort)
medianCount <- apply(countSorted,1,median)
logMedianCount <- log1p(medianCount)
meanLogMedianCount <- mean(logMedianCount)
logMedianCount <- logMedianCount - meanLogMedianCount
quants <- ppoints(1:length(logMedianCount))
plot(y = quants, x = logMedianCount, xlab="Centered log median count",
ylab = "Quantile")
model <- glm(quants ~ logMedianCount + I(logMedianCount^2) + I(logMedianCount^3),
family = binomial(link="logit"))
grid <- seq(min(logMedianCount), max(logMedianCount), length.out=200)
lines(x=grid, y=predict(model, newdata=data.frame(logMedianCount=grid),
type="response"), col="red", lwd=2)
legend("topleft", legend="Estimate", lty=1, col="red", lwd=2, bty='n')
pal <- wesanderson::wes_palette("Zissou1", 20, "continuous")
mypar(mfrow=c(3,2))
betaMat <- matrix(NA, nrow=nlevels(gcgBulk), ncol=4)
meds <- c()
betaList <- list()
grid <- seq(-4, 4, length.out=200)
for(jj in 1:ncol(countsBulk)){
plot(x=grid, y=seq(0,1,length.out=200), type='n', main=paste0("sample ",jj))
for(ii in 1:nlevels(gcgBulk)){
#message(ii)
id <- which(gcgBulk==levels(gcgBulk)[ii])
meds[ii] <- median(gcBulk[id])
countBin <- countsBulk[id,jj,drop=FALSE]
binRes <- suppressWarnings(logisticFQnormIk_beta_rmd(countBin, type='median', plot=FALSE, min.quant=0.01, max.quant=0.99))
betaMat[ii,] <- binRes$betaEst
lines(x=grid, y=binRes$yhat, col=pal[ii])
}
betaList[[jj]] <- betaMat
}
plot <- TRUE
names <- c("Intercept", "Linear", "Quadratic", "Cubic")
medsModel <- rep(meds, ncol(countsBulk))
ss <- as.factor(rep(1:ncol(countsBulk), each=nlevels(gcgBulk)))
betaEstCont <- matrix(NA, nrow=nrow(countsBulk), ncol=4)
if(plot) par(mfrow=c(1,4))
for(jj in 1:4){
# betaHlp <- betaMat[,jj]
betaHlp <- unlist(lapply(betaList, function(x) x[,jj]))
df <- data.frame(beta=betaHlp, gc=medsModel, sample=ss)
mBeta <- gamm4::gamm4(beta ~ s(gc), random = ~(1|sample), data=df)
betaEstCont[,jj] <- predict(mBeta$gam, newdata=data.frame(gc=gcBulk),
type="response")
if(plot){
plot(x=meds, y=betaList[[1]][,jj], type='n',
ylim=range(unlist(lapply(betaList, function(x) x[,jj]))),
main=names[jj], xlim=range(meds))
for(kk in 1:ncol(counts)){
coefHlp <- betaList[[kk]][,jj]
lines(x=meds, y=coefHlp, type='b', col=kk)
}
grid <- seq(min(meds), max(meds), length=200)
lines(x=grid,y=predict(mBeta$gam, newdata=data.frame(gc=grid)),
col="red", lwd=2)
}
}
library(rafalib)
df <- read.csv("~/data/atac/geschwind2018_GSE95023/GSE95023_readswithinpeaks.csv.gz")
counts <- df[,-c(1:3)]
gr <- GRanges(seqnames=df$CHR, ranges=IRanges(df$START, df$END), strand="*", mcols=counts)
ff <- FaFile("~/data/genomes/human/Homo_sapiens.GRCh37.75.dna_sm.primary_assembly.fa")
peakSeqs <- getSeq(x=ff, gr)
gcBulk <- letterFrequency(peakSeqs, "GC",as.prob=TRUE)[,1]
gcgBulk <- Hmisc::cut2(gcBulk, g=20)
# design
patient <- factor(c(rep("A",7), rep("B",6), rep("C",6)))
region <- factor(c(rep("GZ",4), rep("CP",3), rep("GZ",3), rep("CP",3), rep("GZ",3), rep("CP",3)))
# aggregate technical replicates
patReg <- paste0(patient,region)
aggDes <- model.matrix(~0 + patReg)
countsBulk <- as.matrix(counts) %*% aggDes
patientAgg <- factor(rep(c("A", "B", "C"), each=2))
regionAgg <- factor(rep(c("CP", "GZ"),3))
designBulk <- model.matrix(~patientAgg+regionAgg)
rm(df, counts, design, peakSeqs)
logisticFQnormIk_beta_rmd <- function(counts, type="median", plot=TRUE, interval=c(-5,5),
min.quant=0.01, max.quant=0.99){
## input are counts for a specific GC bin.
countSorted <- apply(as.matrix(counts),2,sort)
if(type=="median"){
medianCount <- apply(countSorted,1,median)
} else if(type=="mean"){
medianCount <- apply(countSorted,1,mean)
}
logMedianCount <- log(medianCount+1)
meanLogMedianCount <- mean(logMedianCount)
logMedianCount <- logMedianCount - meanLogMedianCount
o <- order(logMedianCount)
quants <- ppoints(1:length(medianCount))
mMedian <- glm(quants ~ logMedianCount + I(logMedianCount^2) + I(logMedianCount^3), family=binomial(link = "logit"))
betaVector <- coef(mMedian)
grid <- seq(-4, 4, length.out=200)
yhat <- predict(mMedian, newdata=data.frame(logMedianCount = grid), type="response")
return(list(betaEst=betaVector, yhat=yhat))
}
knitr::include_graphics('./gcCpmNgaiLomvardas.png')
countSorted <- apply(countsBulk,2,sort)
medianCount <- apply(countSorted,1,median)
logMedianCount <- log1p(medianCount)
meanLogMedianCount <- mean(logMedianCount)
logMedianCount <- logMedianCount - meanLogMedianCount
quants <- ppoints(1:length(logMedianCount))
plot(y = quants, x = logMedianCount, xlab="Centered log median count",
ylab = "Quantile")
model <- glm(quants ~ logMedianCount + I(logMedianCount^2) + I(logMedianCount^3),
family = binomial(link="logit"))
grid <- seq(min(logMedianCount), max(logMedianCount), length.out=200)
lines(x=grid, y=predict(model, newdata=data.frame(logMedianCount=grid),
type="response"), col="red", lwd=2)
legend("topleft", legend="Estimate", lty=1, col="red", lwd=2, bty='n')
pal <- wesanderson::wes_palette("Zissou1", 20, "continuous")
mypar(mfrow=c(3,2))
betaMat <- matrix(NA, nrow=nlevels(gcgBulk), ncol=4)
meds <- c()
betaList <- list()
grid <- seq(-4, 4, length.out=200)
for(jj in 1:ncol(countsBulk)){
plot(x=grid, y=seq(0,1,length.out=200), type='n', main=paste0("sample ",jj))
for(ii in 1:nlevels(gcgBulk)){
#message(ii)
id <- which(gcgBulk==levels(gcgBulk)[ii])
meds[ii] <- median(gcBulk[id])
countBin <- countsBulk[id,jj,drop=FALSE]
binRes <- suppressWarnings(logisticFQnormIk_beta_rmd(countBin, type='median', plot=FALSE, min.quant=0.01, max.quant=0.99))
betaMat[ii,] <- binRes$betaEst
lines(x=grid, y=binRes$yhat, col=pal[ii])
}
betaList[[jj]] <- betaMat
}
plot <- TRUE
names <- c("Intercept", "Linear", "Quadratic", "Cubic")
medsModel <- rep(meds, ncol(countsBulk))
ss <- as.factor(rep(1:ncol(countsBulk), each=nlevels(gcgBulk)))
betaEstCont <- matrix(NA, nrow=nrow(countsBulk), ncol=4)
if(plot) par(mfrow=c(1,4))
for(jj in 1:4){
# betaHlp <- betaMat[,jj]
betaHlp <- unlist(lapply(betaList, function(x) x[,jj]))
df <- data.frame(beta=betaHlp, gc=medsModel, sample=ss)
mBeta <- gamm4::gamm4(beta ~ s(gc), random = ~(1|sample), data=df)
betaEstCont[,jj] <- predict(mBeta$gam, newdata=data.frame(gc=gcBulk),
type="response")
if(plot){
plot(x=meds, y=betaList[[1]][,jj], type='n',
ylim=range(unlist(lapply(betaList, function(x) x[,jj]))),
main=names[jj], xlim=range(meds))
for(kk in 1:ncol(countsBulk)){
coefHlp <- betaList[[kk]][,jj]
lines(x=meds, y=coefHlp, type='b', col=kk)
}
grid <- seq(min(meds), max(meds), length=200)
lines(x=grid,y=predict(mBeta$gam, newdata=data.frame(gc=grid)),
col="red", lwd=2)
}
}
?glm
rm(list=ls())
