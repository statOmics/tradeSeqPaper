sort(unlist(lapply(goList, length)))
head(sort(unlist(lapply(goList, length)), decreasing=TRUE))
clRSEC
patternGenes[clRSEC==1]
cl1 = patternGenes[clRSEC==1]
cl1
hist(unlist(lapply(goList, function(x) mean(cl1 %in% x))), breaks=20)
max(unlist(lapply(goList, function(x) mean(cl1 %in% x))), breaks=20)
max(unlist(lapply(goList, function(x) mean(cl1 %in% x)))
)
## same number of clusters with PAM.
set.seed(882)
yhatScaled <- resRSEC$yhatScaled
resPam <- cluster::pam(x=yhatScaled, k=length(unique(clRSEC))-1)
clPam <- resPam$clustering
nClusRSEC <- length(unique(clRSEC))-1
maxOverlapsRSEC <- sapply(1:nClusRSEC, function(clust){
clx <- patternGenes[clRSEC == clust]
max(unlist(lapply(goList, function(x) mean(clx %in% x))))
})
hist(maxOverlapsRSEC, breaks=20)
clPam <- resPam$clustering
maxOverlapsPam <- sapply(1:nClusRSEC, function(clust){
clx <- patternGenes[clPam == clust]
max(unlist(lapply(goList, function(x) mean(clx %in% x))))
})
hist(maxOverlapsPam, breaks=20)
hist(maxOverlapsRSEC, breaks=20)
hist(maxOverlapsPam, breaks=20, add=TRUE, col=alpha("steelblue", .4))
boxplot(cbind(maxOverlapsPam, maxOverlapsRSEC))
# hlp <- cherry::construct(goList)
barplot(table(unlist(lapply(goList, length))))
which(unlist(lapply(goList, length)))==1)
which(unlist(lapply(goList, length))==1)
goList[[4305]]
# hlp <- cherry::construct(goList)
listLengths <- unlist(lapply(goList, length))
## filter and make DAG
keep <- listLengths >= 5 & listLengths < 1000
table(keep)
goList <- goList[keep]
hlp <- cherry::construct(goList)
istwoway(hlp)
cherry::istwoway(hlp)
## filter and make DAG
keep <- listLengths >= 5 #& listLengths < 1000
goList <- sapply(uniqGO, function(term){
goMapping$gene[goMapping$go %in% term]
})
names(goList) <- uniqGO
keep <- listLengths >= 5 #& listLengths < 1000
goListFiltered <- goList[keep]
hlp <- cherry::construct(goList)
## filter and make DAG
goList[[length(goList)+1]] <- patternGenes
keep <- listLengths >= 5 #& listLengths < 1000
goListFiltered <- goList[keep]
hlp <- cherry::construct(goList)
hlp <- cherry::construct(goListFiltered)
cl1
## start implementation
clust- <- 1
clx <- patternGenes[clRSEC == clust]
## start implementation
clust <- 1
clx <- patternGenes[clRSEC == clust]
cl
clx
sum(unlist(lapply(goList, function(x) "Ybx1" %in% x)))
class(glBoot)
## the silhouette value is biased to k-means / PAM since it's based on the same distance.
## a non-parametric approach would be to use bootstrapping.
pt <- slingPseudotime(crv,na=FALSE)
cw <- slingCurveWeights(crv)
## bootstrap cells
bootCells <- sample(1:ncol(counts), replace=TRUE)
ptBoot <- pt[bootCells,]
cwBoot <- cw[bootCells,]
countsBoot <- counts[,bootCells]
## refit tradeSeq
glBoot <- fitGAM(countsBoot, pseudotime=ptBoot, cellWeights=cwBoot,
verbose=TRUE, nknots=6)
## cluster using RSEC
rsecBoot <- clusterExpressionPatterns(glBoot, nPoints=100, genes=patternGenes)
rm(hlp)
## cluster using PAM
yhatBoot <- rsecBoot$yhatScaled
pamBoot <- cluster::pam(yhatBoot, k=length(unique(clRSEC))-1)
??adjustedRandIndex
mclust::adjustedRandIndex(primaryCluster(rsecBoot$rsec),
primaryCluster(primaryCluster(resRSEC$rsec)))
mclust::adjustedRandIndex(resPam$clustering,
pamBoot$clustering)
primaryCluster(rsecBoot$rsec)
mclust::adjustedRandIndex(primaryCluster(rsecBoot$rsec),
primaryCluster(resRSEC$rsec))
mclust::adjustedRandIndex(resPam$clustering,
pamBoot$clustering)
rm(list=ls())
setwd("~/Dropbox/compomicsVM/brainstat/hbcRegen/")
#setwd("/home/compomics/Dropbox/compomicsVM/brainstat/hbcRegen/")
here::set_here()
suppressPackageStartupMessages({
library(slingshot)
library(tradeSeq)
library(SingleCellExperiment)
library(cowplot)
library(rgl)
library(clusterExperiment)
library(RColorBrewer)
library(aggregation)
library(ggplot2)
library(pheatmap)
library(wesanderson)
})
sds <- readRDS("slingshot_OE.rds")
load("regenK5_scone_none,fq,ruv_k=1,no_bio,batch_rsec_adjP_mergecutoff_0.01_20190609_085359.Rda")
subset <- readRDS("subset_index.rds")
load("ALL_TF.Rda")
cl <- colnames(sds@clusterLabels)[apply(sds@clusterLabels,1,which.max)]
batch <- droplevels(colData(cl2)$batch[subset])
# # data should have been quantile normalized, but wouldnt we expect all LS to be equal?
# hist(colSums(assays(cl2)$counts), breaks=100)
#
# #
# plot(density(log1p(assays(cl2)$counts[,1])), type='n')
# for(ii in 1:9) lines(density(log1p(assays(cl2)$counts[,ii])), col=ii)
#
plot3d(reducedDim(cl2)[subset,1:3], aspect = 'iso', col=brewer.pal(9,'Set1')[factor(cl)], alpha=.3)
for(i in 1:4){
rgl::plot3d(sds@curves[[i]]$s[, 1:3], type = "l", add = TRUE, lwd = 4, col = "black")
}
offsetHBC <- rep(log(1), length(subset))
# sce <- fitGAM(assays(cl2)$counts[,subset],
#               sds = sds,
# 		          U = NULL,
#               nknots = 7, offset=offsetHBC,
#               parallel = FALSE)
#saveRDS(sce, file="/home/compomics/Dropbox/compomicsVM/brainstat/hbcRegen/sce_noOffset.rds")
sce <- readRDS("sce_noOffset_noBatch.rds")
# labels for plots
labels <- c("Neur", "rHBC", "Sus", "MV")
names(labels) <- as.character(1:4)
source("~/Dropbox/research/PhD/Research/singleCell/trajectoryInference/trajectoryDE/tradeSeq/R/utils.R")
epsilon <- 1e-6
calculateDerivatives <- function(sce, gene, lineage, epsilon=1e-6, nPoints=200){
## gather all required objects
id <- which(rownames(sce) == gene)
beta <- matrix(unlist(rowData(sce)$tradeSeq$beta[id,]),ncol=1)
Sigma <- rowData(sce)$tradeSeq$Sigma[[id]]
X <- colData(sce)$tradeSeq$X
slingshotColData <- colData(sce)$slingshot
pseudotime <- slingshotColData[,grep(x = colnames(slingshotColData),
pattern = "pseudotime")]
dm <- colData(sce)$tradeSeq$dm
## calculate lp matrix with finite differencing
newd1 <- .getPredictRangeDf(dm, lineage, nPoints=nPoints)
newd2 <- newd1
newd1[,paste0("t",lineage)] <- newd1[,paste0("t",lineage)] - epsilon
X0 <- predictGAM(X, newd1, pseudotime)
newd2[,paste0("t",lineage)] <- newd2[,paste0("t",lineage)] + epsilon
X1 <- predictGAM(X, newd2, pseudotime)
Xp <- (X1-X0)/(2*epsilon) ## maps coefficients to (fd approx.) derivatives
## calculate first derivative
df <- Xp%*%beta              ## ith smooth derivative
df.sd <- rowSums(Xp%*%Sigma*Xp)^.5 ## cheap diag(Xi%*%b$Vp%*%t(Xi))^.5
dfsd <- data.frame(der=df, sdDer=df.sd)
colnames(dfsd) <- c(paste0("der",lineage), paste0("sdDer",lineage))
return(dfsd)
}
calculateDerivativesWithSigma <- function(sce, gene, lineage, epsilon=1e-6, nPoints=200){
## gather all required objects
id <- which(rownames(sce) == gene)
beta <- matrix(unlist(rowData(sce)$tradeSeq$beta[id,]),ncol=1)
Sigma <- rowData(sce)$tradeSeq$Sigma[[id]]
X <- colData(sce)$tradeSeq$X
slingshotColData <- colData(sce)$slingshot
pseudotime <- slingshotColData[,grep(x = colnames(slingshotColData),
pattern = "pseudotime")]
dm <- colData(sce)$tradeSeq$dm
## calculate lp matrix with finite differencing
newd1 <- .getPredictRangeDf(dm, lineage, nPoints=nPoints)
newd2 <- newd1
newd1[,paste0("t",lineage)] <- newd1[,paste0("t",lineage)] - epsilon
X0 <- predictGAM(X, newd1, pseudotime)
newd2[,paste0("t",lineage)] <- newd2[,paste0("t",lineage)] + epsilon
X1 <- predictGAM(X, newd2, pseudotime)
Xp <- (X1-X0)/(2*epsilon) ## maps coefficients to (fd approx.) derivatives
## calculate first derivative
df <- Xp%*%beta              ## ith smooth derivative
#df.sd <- rowSums(Xp%*%Sigma*Xp)^.5 ## cheap diag(Xi%*%b$Vp%*%t(Xi))^.5
sigmaDer <- Xp%*%Sigma%*%t(Xp)
dfsd <- list(der=df, sdDer=sigmaDer)
names(dfsd) <- c(paste0("der",lineage), paste0("sdDer",lineage))
return(dfsd)
}
plotSmoothersWithDerivatives <- function(sce, gene, counts, gridDf, derDf){
dfAll <- as.data.frame(cbind(gridDf,derDf))
cowplot::plot_grid(
#smoothers
plotSmoothers(sce, gene=gene, counts=counts, lwd=1),
ggplot(dfAll, aes(x=grid1, y=derDf$der1)) +
geom_line() +
geom_line(aes(x=grid1, y=derDf$der1 - 2*derDf$sdDer1), lty=2) +
geom_line(aes(x=grid1, y=derDf$der1 + 2*derDf$sdDer1), lty=2) +
geom_hline(yintercept=0, col="red") +
ggtitle("Neuronal lineage") +
ylab("First derivative"),
ggplot(dfAll, aes(x=grid2, y=derDf$der2)) +
geom_line() +
geom_line(aes(x=grid2, y=derDf$der2 - 2*derDf$sdDer2), lty=2) +
geom_line(aes(x=grid2, y=derDf$der2 + 2*derDf$sdDer2), lty=2) +
geom_hline(yintercept=0, col="red") +
ggtitle("rHBC lineage") +
ylab("First derivative"),
# test statistics
ggplot(dfAll, aes(x=grid1, y=derDf$der1/derDf$sdDer1)) +
geom_line() +
geom_line(aes(x=grid2, y=derDf$der2/derDf$sdDer2)) +
geom_line(aes(x=grid3, y=derDf$der3/derDf$sdDer3)) +
geom_line(aes(x=grid4, y=derDf$der4/derDf$sdDer4)) +
geom_hline(yintercept=0, col="red") +
ggtitle("Test statistics"),
ggplot(dfAll, aes(x=grid3, y=derDf$der3)) +
geom_line() +
geom_line(aes(x=grid3, y=derDf$der3 - 2*derDf$sdDer3), lty=2) +
geom_line(aes(x=grid3, y=derDf$der3 + 2*derDf$sdDer3), lty=2) +
geom_hline(yintercept=0, col="red") +
ggtitle("SUS lineage") +
ylab("First derivative"),
ggplot(dfAll, aes(x=grid4, y=derDf$der4)) +
geom_line() +
geom_line(aes(x=grid4, y=derDf$der4 - 2*derDf$sdDer4), lty=2) +
geom_line(aes(x=grid4, y=derDf$der4 + 2*derDf$sdDer4), lty=2) +
geom_hline(yintercept=0, col="red") +
ggtitle("MV lineage") +
ylab("First derivative"),
nrow=2, ncol=3
)
}
makeGSEATable <- function(overlapFile, nBP=20){
overlap <- readLines(overlapFile)
overlapSets <- overlap[10:30]
overlapSetsSplit <- sapply(overlapSets, function(x) strsplit(x, split = "\t"))
gsNames <- unname(unlist(lapply(overlapSetsSplit, "[[", 1)))
genesInSet <- unname(unlist(lapply(overlapSetsSplit, "[[", 2)))
genesInOverlap <- unname(unlist(lapply(overlapSetsSplit, "[[", 4)))
pvalUniqGam <- unname(unlist(lapply(overlapSetsSplit, "[[", 6)))
qval <- unname(unlist(lapply(overlapSetsSplit, "[[", 7)))
gsNames <- tolower(gsNames)
gsNames <- gsub(x = gsNames, pattern = "_", replacement = " ")
gsNames[-1] <- unname(sapply(gsNames[-1], function(x) substr(x, 4, nchar(x))))
tab <- data.frame(
geneSet = gsNames[-1],
overlap = as.numeric(genesInOverlap[-1]),
genesInSet = as.numeric(genesInSet[-1]),
qvalue = qval[-1]
)
#library(xtable)
#print(xtable(tab), type="html")
return(tab)
}
tf <- intersect(ALL_TF, rownames(sce))
write.table(tf, "GSEA/tfLookedAt.txt", quote=FALSE,
row.names=FALSE, col.names=FALSE)
# derAllTF <- list()
# for(ii in 1:length(tf)){
#   gene <- tf[ii]
#   derGene <- do.call(cbind, sapply(1:4, function(ll){
#     calculateDerivatives(sce=sce,
#                         gene=gene,
#                         lineage=ll)
#   }, simplify=FALSE))
#   derAllTF[[ii]] <- derGene
# }
# saveRDS(derAllTF, file="derAllTF.rds")
derAllTF <- readRDS("derAllTF.rds")
names(derAllTF) <- tf
# identify relevant pseudotime range for each lineage
dm <- colData(sce)$tradeSeq$dm
nPoints <- 200
grid1 <- tradeSeq:::.getPredictRangeDf(dm, 1, nPoints)
id1 <- which(grid1$t1 > 5 & grid1$t1 < 60)
grid2 <- tradeSeq:::.getPredictRangeDf(dm, 2, nPoints)
id2 <- which(grid2$t2 > 5 & grid2$t2 < 60)
grid3 <- tradeSeq:::.getPredictRangeDf(dm, 3, nPoints)
id3 <- which(grid3$t3 > 5 & grid3$t3 < 60)
grid4 <- tradeSeq:::.getPredictRangeDf(dm, 4, nPoints)
id4 <- which(grid4$t4 > 5 & grid4$t4 < 60)
maxDers <- matrix(NA, nrow=length(tf), ncol=4)
rownames(maxDers) <- tf
for(ii in 1:length(tf)){
gene <- tf[ii]
derTests <- sapply(1:4, function(ll){
rr <- (2*ll-1):(2*ll) #range for the lineage
stat <- derAllTF[[gene]][get(paste0("id",ll)),rr[1]] / derAllTF[[gene]][get(paste0("id",ll)),rr[2]] #test statistic
return(stat)
})
maxDers[ii,] <- unlist(lapply(derTests, max))
}
ooTF <- order(apply(maxDers,1,min), decreasing=TRUE)
# labels for plots
labels <- c("Neur", "rHBC", "Sus", "MV")
names(labels) <- as.character(1:4)
# grid object for plots
gridDf <- data.frame(grid1=grid1$t1, grid2=grid2$t2, grid3=grid3$t3,
grid4=grid4$t4)
ii <- 0
while(ii < 5){
ii <- ii+1
gene = rownames(maxDers)[ooTF[ii]]
#print(suppressMessages(plotSmoothers(sce, gene=gene, counts=assays(cl2)$counts[,subset]) +
#ggtitle(gene) +
#scale_color_viridis_d(labels=labels, alpha=1)))
print(plotSmoothersWithDerivatives(sce, gene=gene,
counts=assays(cl2)$counts[,subset],
gridDf=gridDf,
derDf=derAllTF[[gene]]))
}
setwd("~/Dropbox/research/PhD/research/singleCell/trajectoryInference/trajectoryDE/tradeSeqPaper/simulation/")
library(here)
library(slingshot)
library(RColorBrewer)
library(mgcv)
library(tradeSeq)
library(edgeR)
library(rafalib)
library(wesanderson)
library(ggplot2)
library(cowplot)
library(iCOBRA)
library(scales)
library(dplyr)
### prepare performance plots ####
cols <- c(rep(c("#C6DBEF", "#08306B"), each = 3), "#4292C6", "#4daf4a",
"#e41a1c", "#e78ac3", "#ff7f00", "dodgerblue")
names(cols) <- c("tradeSeq_slingshot_end", "tradeSeq_GPfates_end", "tradeSeq_Monocle2_end",
"tradeSeq_slingshot_pattern", "tradeSeq_GPfates_pattern",
"tradeSeq_Monocle2_pattern", "tradeSeq_slingshot_assoc", "Monocle3_assoc",
"BEAM", "GPfates", "edgeR", "tradeSeq_slingshot_UMAP_assoc")
linetypes <- c(rep(c("dashed", "dotdash", "solid"), 2), rep("solid", 7))
names(linetypes) <- c("tradeSeq_slingshot_end", "tradeSeq_GPfates_end", "tradeSeq_Monocle2_end",
"tradeSeq_slingshot_pattern", "tradeSeq_GPfates_pattern",
"tradeSeq_Monocle2_pattern", "tradeSeq_slingshot_assoc", "Monocle3_assoc",
"BEAM", "GPfates", "edgeR", "tradeSeq_slingshot_UMAP_assoc")
theme_set(theme_bw())
theme_update(legend.position = "none",
panel.grid.major.y = element_blank(),
panel.grid.minor.y = element_blank(),
panel.grid.major.x = element_line(linetype = "dashed", colour = "black"),
panel.grid.minor.x = element_line(linetype = "dashed", colour = "grey"),
axis.title.x = element_text(size = rel(1)),
axis.title.y = element_text(size = rel(1)),
axis.text.x = element_text(size = rel(.8)),
axis.text.y = element_text(size = rel(.8)))
dir <- "~/Dropbox/research/PhD/research/singleCell/trajectoryInference/trajectoryDE/tradeSeqPaper/simulation/sim2_dyngen_cycle_72/datasets"
cobraFiles <- list.files(dir, pattern="*_v2IncludingEdgeR.rds$", full.names=TRUE)
cobraFiles <- cobraFiles[c(1,3:10,2)] #order from 1 to 10
plotPerformanceCurve <- function(cobraObject){
cn <- colnames(pval(cobraObject))
cn <- gsub(cn,pattern="tradeR",replacement="tradeSeq")
cn[cn == "Monocle3"] <- "Monocle3_assoc"
colnames(pval(cobraObject)) <- cn
cobraObject <- calculate_adjp(cobraObject)
cobraObject <- calculate_performance(cobraObject, binary_truth = "status")
DyntoyPlot <- data.frame(FDP = cobraObject@fdrtprcurve$FDR,
TPR = cobraObject@fdrtprcurve$TPR,
method = cobraObject@fdrtprcurve$method,
cutoff = cobraObject@fdrtprcurve$CUTOFF)
pDyntoy <- ggplot(DyntoyPlot, aes(x = FDP, y = TPR, col = method)) +
geom_path(size = 1, aes(linetype = method)) +
xlab("FDP") +
scale_x_continuous(limits = c(0, 1), breaks = c(0.01, 0.05, 0.1, 0.5, 1),
minor_breaks = c(0:5) * .1) +
scale_y_continuous(limits = c(0, 1)) +
scale_color_manual(values = cols, breaks = names(cols)) +
scale_linetype_manual(values = linetypes, breaks = names(linetypes))
pDyntoy
}
## write source data file
# for(ii in 1:length(cobraFiles)){
#     cobra <- readRDS(cobraFiles[ii])
#     write.table(pval(cobra), file=paste0("~/sourceDataTradeSeq/fig3/cyclic/pvalDataset",ii,".txt"))
# }
for(ii in 1:length(cobraFiles)){
cobra <- readRDS(cobraFiles[ii])
assign(paste0("bifplot",ii),plotPerformanceCurve(cobra))
}
p1 <- plot_grid(bifplot1, bifplot2, bifplot3, bifplot4, bifplot5,
bifplot6, bifplot7, bifplot8, bifplot9, bifplot10,
nrow=2, ncol=5)
p1
plotsBif <- sapply(cobraFiles, function(file){
cobra <- readRDS(file)
plotPerformanceCurve(cobra)
})
resPlots <- plotsBif[seq(1,length(plotsBif),by=9)] # get relevant data frame
pAll <- ggplot(resPlots[[1]],
aes(x = FDP, y = TPR, col = method)) +
geom_path(size = 1, aes(linetype = method)) +
scale_color_manual(values = cols, breaks = names(cols)) +
scale_linetype_manual(values = linetypes, breaks = names(linetypes))  + guides(fill=guide_legend(nrow=3))
legend_all <- get_legend(pAll + labs(col = "", linetype = "") +
theme(legend.position = "bottom",
legend.key.width = unit(1.3, "cm")))
pLeg <- plot_grid(pAll, legend_all, rel_heights=c(1,0.2), nrow=2, ncol=1)
pLeg
#### plot with trajectories
FQnorm <- function(counts){
rk <- apply(counts,2,rank,ties.method='min')
counts.sort <- apply(counts,2,sort)
refdist <- apply(counts.sort,1,median)
norm <- apply(rk,2,function(r){ refdist[r] })
rownames(norm) <- rownames(counts)
return(norm)
}
pal <- wes_palette("Zissou1", 12, type = "continuous")
dataAll <- readRDS("~/Dropbox/research/PhD/research/singleCell/trajectoryInference/trajectoryDE/tradeSeqPaper/simulation/sim2_dyngen_cycle_72/datasets/datasets_for_koen.rds")
for(datasetIter in c(1:10)){
data <- dataAll[[datasetIter]]
counts <- t(data$counts)
# get milestones
gid <- data$prior_information$groups_id
gid <- gid[match(colnames(counts),gid$cell_id),]
pal <- wes_palette("Zissou1", 12, type = "continuous")
truePseudotime <- data$prior_information$timecourse_continuous
g <- Hmisc::cut2(truePseudotime,g=12)
# quantile normalization
normCounts <- FQnorm(counts)
## dim red
pca <- prcomp(log1p(t(normCounts)), scale. = FALSE)
rd <- pca$x[,1:2]
#plot(rd, pch=16, asp = 1, col=pal[g])
library(princurve)
pcc <- principal_curve(rd, smoother="periodic_lowess")
#lines(x=pcc$s[order(pcc$lambda),1], y=pcc$s[order(pcc$lambda),2], col="red", lwd=2)
ggTraj <- ggplot(as.data.frame(rd), aes(x = PC1, y = PC2)) +
geom_point(col = pal[g], size=1) +
theme_classic() +
geom_path(x = pcc$s[order(pcc$lambda),1],
y = pcc$s[order(pcc$lambda),2])
assign(paste0("trajplot",datasetIter),ggTraj)
}
p1 <- plot_grid(trajplot1 + coord_fixed(), trajplot2 + coord_fixed(), trajplot3 + coord_fixed(), trajplot4 + coord_fixed(), trajplot5 + coord_fixed(),
bifplot1 + coord_fixed(), bifplot2 + coord_fixed(), bifplot3 + coord_fixed(), bifplot4 + coord_fixed(), bifplot5 + coord_fixed(),
nrow=2, ncol=5)#, rel_heights=c(0.8,1,0.8,1))
pLeg1 <- plot_grid(p1, legend_all, rel_heights=c(1,0.15), nrow=2, ncol=1)
pLeg1
ggsave("~/Dropbox/resarch/PhD/research/singleCell/trajectoryInference/trajectoryDE/tradeSeqPaper/simulation/sim2_dyngen_cycle_72/individualPerformance_cyclic1To5_v2IncludingEdgeR.pdf", width = unit(15, "in"), height = unit(10, "in"), scale = .7)
### fixed aspect ratio
p1 <- plot_grid(trajplot1 + coord_fixed(), trajplot2 + coord_fixed(), trajplot3 + coord_fixed(), trajplot4 + coord_fixed(), trajplot5 + coord_fixed(),
bifplot1 + coord_fixed(), bifplot2 + coord_fixed(), bifplot3 + coord_fixed(), bifplot4 + coord_fixed(), bifplot5 + coord_fixed(),
nrow=2, ncol=5)#, rel_heights=c(0.8,1,0.8,1))
pLeg1 <- plot_grid(p1, legend_all, rel_heights=c(1,0.15), nrow=2, ncol=1)
pLeg1
ggsave("~/Dropbox/research/PhD/research/singleCell/trajectoryInference/trajectoryDE/tradeSeqPaper/simulation/sim2_dyngen_cycle_72/individualPerformance_cyclic1To5_v2IncludingEdgeR.pdf", width = unit(15, "in"), height = unit(10, "in"), scale = .7)
p2 <- plot_grid(trajplot6 + coord_fixed(), trajplot7 + coord_fixed(), trajplot8 + coord_fixed(), trajplot9 + coord_fixed(), trajplot10 + coord_fixed(),
bifplot6 + coord_fixed(), bifplot7 + coord_fixed(), bifplot8 + coord_fixed(), bifplot9 + coord_fixed(), bifplot10 + coord_fixed(),
nrow=2, ncol=5, rel_heights=c(0.8,1))
pLeg2 <- plot_grid(p2, legend_all, rel_heights=c(1,0.15), nrow=2, ncol=1)
pLeg2
ii=1
ii=1
### mean plot
resList <- c()
alphaSeq <- c(seq(1e-16,1e-9,length=100),seq(5e-9,1e-3,length=250),seq(5e-2,1,length=500))
cobra <- readRDS(cobraFiles[ii])
pvals <- pval(cobra)
head(pvals)
### mean plot
resList <- c()
alphaSeq <- c(seq(1e-16,1e-9,length=100),seq(5e-9,1e-3,length=250),seq(5e-2,1,length=500))
for(ii in 1:length(cobraFiles)){
cobra <- readRDS(cobraFiles[ii])
pvals <- pval(cobra)
if(all(pvals$Monocle3 == 1)) next
colnames(pvals) <- gsub(colnames(pvals),pattern="tradeR",replacement="tradeSeq")
truths <- as.logical(truth(cobra)[,1])
# performance for all p-value based methods
hlp <- apply(pvals,2,function(x){
#pOrder <- order(x,decreasing=FALSE)
padj <- p.adjust(x,"fdr")
df <- as.data.frame(t(sapply(alphaSeq, function(alpha){
R <- which(padj <= alpha)
fdr <- sum(!truths[R])/length(R) #false over rejected
tpr <- sum(truths[R])/sum(truths) #TP over all true
c(fdr=fdr, tpr=tpr, cutoff=alpha)
})))
})
# summarize
dfIter <- do.call(rbind,hlp)
dfIter$method=rep(colnames(pvals),each=length(alphaSeq))
dfIter$dataset <- ii
resList[[ii]] <- dfIter
}
#### across all datasets
library(tidyverse)
df <- as_tibble(do.call(rbind,resList))
df$method <- gsub(x=df$method,pattern="Monocle3",replacement="Monocle3_assoc")
df <- df %>% group_by(method,cutoff) %>%
summarize(meanTPR=mean(tpr,na.rm=TRUE),
meanFDR=mean(fdr,na.rm=TRUE)) %>% arrange(method,cutoff)
pMeanAll <- ggplot(df, aes(x=meanFDR, y=meanTPR, col=method)) + geom_path(size = 1) +
scale_x_continuous(limits = c(0, 1), breaks = c(0.01, 0.05, 0.1),
minor_breaks = c(0:5) * .1) +
scale_y_continuous(limits = c(0, 1)) +
scale_color_manual(values = cols, breaks = names(cols)) +
scale_linetype_manual(values = linetypes, breaks = names(linetypes)) + xlab("FDR") + ylab("TPR")
pMeanLegAll <- plot_grid(pMeanAll, legend_all, rel_heights=c(1,0.15), nrow=2, ncol=1)
pMeanLegAll
pMeanLegAll
saveRDS(pMeanAll, file="~/Dropbox/research/PhD/research/singleCell/trajectoryInference/trajectoryDE/tradeSeqPaper/simulation/performancePlots/pMeanCycle_v2IncludingEdgeR.rds")
